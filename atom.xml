<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>孖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-12T06:51:03.367Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>孖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>均衡负载</title>
    <link href="http://yoursite.com/2018/09/12/%E5%9D%87%E8%A1%A1%E8%B4%9F%E8%BD%BD-mabowen/"/>
    <id>http://yoursite.com/2018/09/12/均衡负载-mabowen/</id>
    <published>2018-09-12T06:19:55.601Z</published>
    <updated>2018-09-12T06:51:03.367Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是均衡负载"><a href="#什么是均衡负载" class="headerlink" title="什么是均衡负载"></a>什么是均衡负载</h3><p>早期的互联网应用,由于用户流量小,业务逻辑比较简单,往往一个服务器就能满足均衡负载,随着互联网的流量越来越大,稍微好一点的系统,访问量就非常大了,那么就算单台服务器性能优化的再好,也不能支撑这么大的用户量的访问压力</p><p>此时就需要请出负载均衡器入场了  </p><p>负载均衡是指把用户访问的流量,通过”负载均衡器”,根据某种转发的策略,均匀的分发到后端多台服务器上,后端的服务器可以独立的响应和处理请求,从而实现分散负债的效果.负载均衡技术提高了系统的服务能力,增强了应用的可用性</p><h3 id="主流负载均衡方案有几种"><a href="#主流负载均衡方案有几种" class="headerlink" title="主流负载均衡方案有几种?"></a>主流负载均衡方案有几种?</h3><ol><li><p>基于DNS负载均衡</p></li><li><p>基于硬件负载均衡:比如F5</p></li><li><p>基于软件负载均衡:比如Nginx,Squid</p></li></ol><h4 id="基于DNS负载均衡"><a href="#基于DNS负载均衡" class="headerlink" title="基于DNS负载均衡"></a>基于DNS负载均衡</h4><p>其原理就是:当用户访问域名的时候,会先向DNS服务器去解析域名对应的IP地址,这个时候我们可以让DNS服务器根据不同地理位置的用户返回不同的IP.</p><p>在这个模式下,用户就相当于实现了按照”就近原则”将请求分流了,既减轻了单个集群的负载压力,也提高了用户的访问速度</p><p>使用DNS做负载均衡的方案,优势是配置简单,实现成本低</p><h4 id="基于硬件负载均衡"><a href="#基于硬件负载均衡" class="headerlink" title="基于硬件负载均衡"></a>基于硬件负载均衡</h4><p>比如F5,他是一个网络设备,你可以理解为类似于网络交换机的东西,完全通过硬件来抗压力,性能是非常的好,每秒能处理请求达到百万级,采用硬件做负载均衡的话,主要就是省心省事,买一台就搞定,性能强大,一般的业务不在话下,而且在负载均衡的算法还支持很多灵活的策略,同时还具有一些防火墙等安全功能</p><h4 id="基于软件负载均衡"><a href="#基于软件负载均衡" class="headerlink" title="基于软件负载均衡"></a>基于软件负载均衡</h4><p>软件负载均衡是指使用软件的方式来分发和均衡流量.软件负载均衡分为7层协议和4层协议</p><p>网络协议有七层,基于第四层传输层来做流量分发的方案称为四层负载均衡,例如LVS;而基于第七层应用层来做流量分发的成为7层负载均衡,例如Nginx,这两种在性能和灵活性上是有区别的</p><p>基于4层的负载均衡性能要高一点,一般能达到几十万/秒的处理量,而基于7层的负载均衡处理量一般只在几万/秒</p><p>基于软件的负载均衡的特点也很明显,便宜.在正常的服务器上部署即可,无需额外采购,就是投入一点点技术去优化优化即可,因此这种方式是互联网公司中用的最多的方式了</p><h4 id="常见的均衡算法有哪些"><a href="#常见的均衡算法有哪些" class="headerlink" title="常见的均衡算法有哪些"></a>常见的均衡算法有哪些</h4><ol><li>轮询策略</li><li>负载度策略</li><li>响应策略</li><li>哈希策略</li></ol><p><a href="https://my.oschina.net/u/3915715/blog/2049487" target="_blank" rel="noopener">详情</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;什么是均衡负载&quot;&gt;&lt;a href=&quot;#什么是均衡负载&quot; class=&quot;headerlink&quot; title=&quot;什么是均衡负载&quot;&gt;&lt;/a&gt;什么是均衡负载&lt;/h3&gt;&lt;p&gt;早期的互联网应用,由于用户流量小,业务逻辑比较简单,往往一个服务器就能满足均衡负载,随着互联网的流量
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python20行代码检测单删</title>
    <link href="http://yoursite.com/2018/08/23/python20%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%A3%80%E6%B5%8B%E5%BE%AE%E4%BF%A1%E5%8D%95%E5%88%A0-mabowen/"/>
    <id>http://yoursite.com/2018/08/23/python20行代码检测微信单删-mabowen/</id>
    <published>2018-08-23T07:20:23.493Z</published>
    <updated>2018-08-23T07:46:48.466Z</updated>
    
    <content type="html"><![CDATA[<p>学习了python几天,无意中看见了itchat库,itchat库提供了许多微信的接口,很强大.<br>无意中发现了一个特殊字符,使用微信发送收不到.<br>那可以通过循环发好友发送特殊字符,来判断好友的关系<br>美中不足的是,我没找到删除好友的方法<br>还有一点想法没有实现,通过注册方法获取发送后note类型的通知,如果被删除好友或者被拉黑会才会有,而发送特殊字符成功不会又任何提示,这样就可以获取到好友的信息,如果知道删除好友的办法就可以做删好友的处理<br>特殊字符哪时候被封也不清楚,如果谁看见这篇文章,想要使用,记得先检测下特殊字符发送后对面能不能收到,<br>如果谁实现了希望可以与我分享下,wechat:mbw5200</p><p><a href="https://itchat.readthedocs.io/zh/latest/" target="_blank" rel="noopener">itchat文档</a><br><a href="http://www.sohu.com/a/226268082_99960093" target="_blank" rel="noopener">特殊字符</a>  </p><p>打包的exe文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: https://pan.baidu.com/s/14iUbI5jBQMetj2-_di6tKg 密码: n54x</span><br></pre></td></tr></table></figure><p>源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author :mabowen</span><br><span class="line"># @Time   :2018/8/15 19:56</span><br><span class="line">import itchat, time</span><br><span class="line">#登陆</span><br><span class="line">itchat.auto_login()</span><br><span class="line">#获取好友列表</span><br><span class="line">friendList = itchat.get_friends(update=True)[1:]</span><br><span class="line">num = [0,1]</span><br><span class="line"></span><br><span class="line">def send(g, num):</span><br><span class="line">    itchat.send(&apos;? ? ?&apos;, friendList[g + num][&apos;UserName&apos;])</span><br><span class="line">    print((friendList[g + num][&apos;RemarkName&apos;] or friendList[g + num][&apos;NickName&apos;]), &apos;已发送&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">itchat.send(&apos;正在开始测试&apos;, &apos;filehelper&apos;)</span><br><span class="line">#预估时间</span><br><span class="line">needtime = round(1+int(len(friendList)) /2/60, 2)</span><br><span class="line">itchat.send(&apos;共&apos; + str(len(friendList)) + &apos;人&apos; + &apos;\n预计需要&apos; + str(needtime) + &apos;min&apos;, &apos;filehelper&apos;)</span><br><span class="line">#循环给各个好友发送信息,1s发两条</span><br><span class="line">for g in range(0, len(friendList), 2):</span><br><span class="line">    for i in num:</span><br><span class="line">        if g + i &lt; len(friendList):</span><br><span class="line">            #发送特殊字符</span><br><span class="line">            send(g, i)</span><br><span class="line">            print(str(g + i+1) + &quot;/&quot; + str(len(friendList)) + &quot;\r&quot;)</span><br><span class="line">    #限制频率</span><br><span class="line">    time.sleep(1)</span><br><span class="line"></span><br><span class="line">itchat.send(&apos;结束测试,请在聊天列表页查看&apos;, &apos;filehelper&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习了python几天,无意中看见了itchat库,itchat库提供了许多微信的接口,很强大.&lt;br&gt;无意中发现了一个特殊字符,使用微信发送收不到.&lt;br&gt;那可以通过循环发好友发送特殊字符,来判断好友的关系&lt;br&gt;美中不足的是,我没找到删除好友的方法&lt;br&gt;还有一点想法没
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python学习</title>
    <link href="http://yoursite.com/2018/08/17/python%E5%AD%A6%E4%B9%A0-mabowen/"/>
    <id>http://yoursite.com/2018/08/17/python学习-mabowen/</id>
    <published>2018-08-17T01:45:48.004Z</published>
    <updated>2018-08-24T01:26:51.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的命名和使用"><a href="#变量的命名和使用" class="headerlink" title="变量的命名和使用"></a>变量的命名和使用</h4><ol><li><p>变量名只能包括字母,数字和下划线.变量名可以字母或下划线打头,但不能以数字打头</p></li><li><p>变量名不能包含空格,但是可以使用下划线来分隔其中的单词</p></li><li><p>不要将python关键字和函数名作变量名</p></li><li><p>变量名应既简短又具有描述性</p></li><li><p>慎用小写字母1和大写字母O,容易误看</p></li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在python中,用引号括起的都是字符串,可以是单引号也可以是双引号</p><p>拼接符合 ‘+’</p><h3 id="列表是什么"><a href="#列表是什么" class="headerlink" title="列表是什么"></a>列表是什么</h3><p>在python中,用方括号来表示列表,并用逗号来分隔其中元素.</p><h4 id="访问列表元素"><a href="#访问列表元素" class="headerlink" title="访问列表元素"></a>访问列表元素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test=[0,1,2,3,4]</span><br><span class="line">print(test[0])</span><br></pre></td></tr></table></figure><h4 id="修改-添加和删除列表元素"><a href="#修改-添加和删除列表元素" class="headerlink" title="修改,添加和删除列表元素"></a>修改,添加和删除列表元素</h4><p>修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=[0,1,2,3,4]   </span><br><span class="line">test[0]=-1  </span><br><span class="line">print(test)</span><br></pre></td></tr></table></figure><p>添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=[0,1,2,3,4]</span><br><span class="line">test.append(5)</span><br><span class="line">print</span><br></pre></td></tr></table></figure><p>插入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=[1,2,3,4]</span><br><span class="line">test.insert(0,0)</span><br><span class="line">print(test)</span><br></pre></td></tr></table></figure><p>删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=[0,1,2,3,4]</span><br><span class="line">del test[0]</span><br><span class="line">print(test)</span><br></pre></td></tr></table></figure><p>或者pop删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test=[1,2,3,4]</span><br><span class="line">print(test)</span><br><span class="line">pop_test=test.pop(1)</span><br><span class="line">print(test)</span><br><span class="line">print(pop_test)</span><br></pre></td></tr></table></figure><p>rmove根据值删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test=[0,1,2,3,4]</span><br><span class="line">test.remove(4)</span><br><span class="line">print(test)</span><br></pre></td></tr></table></figure><h4 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h4><p>1.sort方法是永久排序</p><p>2.sorted方法是临时排序</p><p>3.reverse方法反转列表元素的排列顺序</p><p>4.len方法获取列表长度</p><h3 id="遍历整个列表"><a href="#遍历整个列表" class="headerlink" title="遍历整个列表"></a>遍历整个列表</h3><p>for循环,注意缩进 格式</p><h4 id="使用函数range"><a href="#使用函数range" class="headerlink" title="使用函数range()"></a>使用函数range()</h4><p>range()方法让你能轻松生成一系列数字</p><h4 id="简单统计计算"><a href="#简单统计计算" class="headerlink" title="简单统计计算"></a>简单统计计算</h4><p>1.min找出最小值</p><p>2.max找出最大值</p><p>3.sum求和</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>切片可以指定要使用的第一个元素和最后一个元素的索引.</p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组看起来犹如列表,但使用圆括号而不是方括号来标识.定义元组后,就可以使用索引来访问元素,就像访问列表元素一样<br><strong>元组不可以修改</strong></p><h3 id="遵循标准"><a href="#遵循标准" class="headerlink" title="遵循标准"></a>遵循标准</h3><p>PEP8标准</p><h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3><p>条件判断 </p><p>检查特定值在不在列表内</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test=[1,2,3]</span><br><span class="line">1 in test</span><br></pre></td></tr></table></figure><p>if-elif-else 结构</p><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是 键-值对  </p><h4 id="添加键值对"><a href="#添加键值对" class="headerlink" title="添加键值对"></a>添加键值对</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test=&#123;</span><br><span class="line">   &apos;1&apos;:1</span><br><span class="line">   &apos;2&apos;:2</span><br><span class="line">&#125;</span><br><span class="line">test[&apos;3&apos;]=3</span><br><span class="line">print(test)</span><br></pre></td></tr></table></figure><h4 id="删除键值对"><a href="#删除键值对" class="headerlink" title="删除键值对"></a>删除键值对</h4><p>del test[‘3’]</p><h4 id="遍历循环字典键值对"><a href="#遍历循环字典键值对" class="headerlink" title="遍历循环字典键值对"></a>遍历循环字典键值对</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;</span><br><span class="line"> &apos;username&apos;: &apos;efermi&apos;,</span><br><span class="line"> &apos;first&apos;: &apos;enrico&apos;,</span><br><span class="line"> &apos;last&apos;: &apos;fermi&apos;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">for k,v in user_0.items():</span><br><span class="line">    print(k,&apos;:&apos;,v)</span><br></pre></td></tr></table></figure><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4><p>set() 可让python找出列表独一无二的元素,并使用着些元素创建一个集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user_0 = &#123;</span><br><span class="line"> &apos;username&apos;: &apos;fermi&apos;,</span><br><span class="line"> &apos;first&apos;: &apos;enrico&apos;,</span><br><span class="line"> &apos;last&apos;: &apos;fermi&apos;,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">for v in set(user_0.values()):</span><br><span class="line">    print(v)</span><br></pre></td></tr></table></figure><h4 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alien_0 = &#123;&apos;color&apos;: &apos;green&apos;, &apos;points&apos;: 5&#125;</span><br><span class="line">alien_1 = &#123;&apos;color&apos;: &apos;yellow&apos;, &apos;points&apos;: 10&#125;</span><br><span class="line">alien_2 = &#123;&apos;color&apos;: &apos;red&apos;, &apos;points&apos;: 15&#125;</span><br><span class="line">aliens = [alien_0, alien_1, alien_2]</span><br><span class="line">for alien in aliens:</span><br><span class="line"> print(alien)</span><br></pre></td></tr></table></figure><h3 id="用户输入和while循环"><a href="#用户输入和while循环" class="headerlink" title="用户输入和while循环"></a>用户输入和while循环</h3><h4 id="input"><a href="#input" class="headerlink" title="input"></a>input</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a=input(&apos;请输入:&apos;)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><h4 id="求模运算符号"><a href="#求模运算符号" class="headerlink" title="求模运算符号%"></a>求模运算符号%</h4><p>求摸运算符不会指出一个数是另一个数的多少倍,而只指出余数是多少</p><h4 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h4><p>break 语句可以立刻退出循环</p><p>continue 语句跳过此次循环</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p><strong>init</strong> 每次你根据类创建新的实列,python都会自动运行它</p><h4 id="根据类创建实例"><a href="#根据类创建实例" class="headerlink" title="根据类创建实例"></a>根据类创建实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Dog():</span><br><span class="line">    def __init__(self,name,age):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.age=age</span><br><span class="line">    def sit(self):</span><br><span class="line">        print(self.name.title()+&apos;is now sitting&apos;)</span><br><span class="line">    def roll_over(self):</span><br><span class="line">        print(self.name.title()+&apos;rolled over&apos;)</span><br><span class="line"></span><br><span class="line">my_dog=Dog(&apos;willie&apos;,6)</span><br><span class="line">my_dog.sit()</span><br></pre></td></tr></table></figure><p>根据实例 可以调用类的方法</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><h4 id="类编码分隔"><a href="#类编码分隔" class="headerlink" title="类编码分隔"></a>类编码分隔</h4><p>类名采用驼峰命名法<br>实列名和模块名都采用小写格式并且在单词之间加上下划线</p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p><code>`</code><br>with open(‘pi.txt’) as file_object:<br>   s=file_object.read()<br>   print(s)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h3&gt;&lt;h4 id=&quot;变量的命名和使用&quot;&gt;&lt;a href=&quot;#变量的命名和使用&quot; class=&quot;headerlink&quot; title=&quot;变量的命名和使用&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>PHP 合并数组运算符 + 与 array_merge 函数</title>
    <link href="http://yoursite.com/2018/07/24/PHP%E5%90%88%E5%B9%B6%E6%95%B0%E7%BB%84-mabowen/"/>
    <id>http://yoursite.com/2018/07/24/PHP合并数组-mabowen/</id>
    <published>2018-07-24T12:11:48.092Z</published>
    <updated>2018-07-24T12:25:36.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="在php中对两个数组进行合并-通常使用array-merge或者’-’运算符-他们的区别是什么"><a href="#在php中对两个数组进行合并-通常使用array-merge或者’-’运算符-他们的区别是什么" class="headerlink" title="在php中对两个数组进行合并,通常使用array_merge或者’+’运算符 他们的区别是什么"></a>在php中对两个数组进行合并,通常使用array_merge或者’+’运算符 他们的区别是什么</h3><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?php</span><br><span class="line">$cfg = [</span><br><span class="line">    0 =&gt; &apos;cfg-1&apos;,</span><br><span class="line">    1 =&gt; &apos;cfg-1&apos;,</span><br><span class="line">    &apos;name&apos; =&gt; &apos;hlq&apos;,</span><br><span class="line">    &apos;age&apos; =&gt; 18,</span><br><span class="line">    &apos;job&apos; =&gt; &apos;engineer&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">$default = [</span><br><span class="line">    0 =&gt; &apos;default-0&apos;,</span><br><span class="line">    1 =&gt; &apos;default-1&apos;,</span><br><span class="line">    &apos;name&apos; =&gt; &apos;hlq&apos;,</span><br><span class="line">    &apos;age&apos; =&gt; 16,</span><br><span class="line">    &apos;hobby&apos; =&gt; &apos;readding&apos;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">var_dump($cfg + $default);</span><br><span class="line"></span><br><span class="line">var_dump(array_merge($cfg, $default));</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">array(6) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(5) &quot;cfg-1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(5) &quot;cfg-1&quot;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(3) &quot;hlq&quot;</span><br><span class="line">  [&quot;age&quot;]=&gt;</span><br><span class="line">  int(18)</span><br><span class="line">  [&quot;job&quot;]=&gt;</span><br><span class="line">  string(8) &quot;engineer&quot;</span><br><span class="line">  [&quot;hobby&quot;]=&gt;</span><br><span class="line">  string(8) &quot;readding&quot;</span><br><span class="line">&#125;</span><br><span class="line">array(8) &#123;</span><br><span class="line">  [0]=&gt;</span><br><span class="line">  string(5) &quot;cfg-1&quot;</span><br><span class="line">  [1]=&gt;</span><br><span class="line">  string(5) &quot;cfg-1&quot;</span><br><span class="line">  [&quot;name&quot;]=&gt;</span><br><span class="line">  string(3) &quot;hlq&quot;</span><br><span class="line">  [&quot;age&quot;]=&gt;</span><br><span class="line">  int(16)</span><br><span class="line">  [&quot;job&quot;]=&gt;</span><br><span class="line">  string(8) &quot;engineer&quot;</span><br><span class="line">  [2]=&gt;</span><br><span class="line">  string(9) &quot;default-0&quot;</span><br><span class="line">  [3]=&gt;</span><br><span class="line">  string(9) &quot;default-1&quot;</span><br><span class="line">  [&quot;hobby&quot;]=&gt;</span><br><span class="line">  string(8) &quot;readding&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ul><li>array_merge和 ‘+’ 都可以合并数组</li><li>array_merge会对相同字符串键名,用后面的数据重写数据,而加号不会</li><li>array_merge对数字键名数据不会重写,而是根据数字键名接着写入数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;在php中对两个数组进行合并-通常使用array-merge或者’-’运算符-他们的区别是什么&quot;&gt;&lt;a href=&quot;#在php中对两个数组进行合并-通常使用array-merge或者’-’运算符-他们的区别是什么&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>写给新生</title>
    <link href="http://yoursite.com/2018/07/01/%E5%86%99%E7%BB%99%E6%96%B0%E7%94%9F-mabowen/"/>
    <id>http://yoursite.com/2018/07/01/写给新生-mabowen/</id>
    <published>2018-07-01T08:50:51.853Z</published>
    <updated>2018-07-23T07:06:14.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学校"><a href="#学校" class="headerlink" title="学校"></a>学校</h3><ul><li>学校男女比例 3:7到4:6的样子,女孩子是多于男的  </li><li>学校两个校区,统招是在滨江校区,成教是在德胜校区</li><li>学校占地面积是 500多亩 别问大不大 这主观性太强 (个人觉得不是太大) 大不大你自己看 </li><li>大一学校活动也蛮多 很多晚会 (需要抢票)  还有很多社团(我没有参加过 不大清楚)</li><li>大一大部分同学是有早晚自修(应该是都要)  <ul><li>早自习7.15-8.05  </li><li>晚自习17.50-20.15  </li></ul></li><li>学校离垃圾街不远(小吃街) 离 <strong>立业园</strong> (学校的一个寝室园区)很近</li><li>寝室园区会有很多收快递的站点 不用担心自己上课 不方便收快递</li><li>学校有三种wifi<br>1.移动的 要有移动账号<br>2.电信的 要有电信账号(这个是有在寝室园区搜的到)<br>3.zjbc 学校提供的(这个只有学校里面搜的到)  </li><li><a href="http://zs.zjbc.edu.cn/vr/index.html" target="_blank" rel="noopener">学校VR全景</a></li></ul><h3 id="宿舍"><a href="#宿舍" class="headerlink" title="宿舍"></a>宿舍</h3><ul><li>宿舍是开学前几天学校网上给你几个寝室选,这几个寝室全是你班里的同学和你选   </li><li>六人寝室(有版本:说有四人但基本不会是你的)</li><li>不是上床下桌 (因为是六人 有两张床铺是上床下桌)</li><li>有空调(和室友一起合租一个 用三年费用大概是300上下 毕业有退100上下 保存好合同)<br><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=aa26bfbc4d90f60304b09c4f0913b370/1151364e251f95caf16ca13bce177f3e66095278.jpg" alt="空调费用"></li><li>有独卫里面有个蹲坑 有个淋浴(时间段的提供热水) 有面镜子 有个洗漱台</li><li>床上用品可以自己带 具体大小和你高中的应该是一样的(新生群有宿舍规格表可以看看)</li><li>有饮水机(自己租 多少忘记了 不贵)</li><li>寝室可以装一个WiFi买个路由器(用自己的移动账号可以 不会装找会装的人   <strong>电信账号不能用于路由器!!!</strong>)</li><li>宿舍照片 贴吧很容易找到 自己可以翻一番</li><li>学校有三个寝室楼 <ol><li>大部分学生是住在 <strong>立志园</strong>  </li><li>部分学院的女生(只能是女生 <strong>这个不是水泥地</strong> ) 可以住在位于学校里面的 <strong>综合楼</strong> </li><li>一小部分住在 <strong>立业园</strong> </li></ol></li></ul><h3 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h3><p>学校的图书馆位于学校里面 有两个自修室 可以用自己的校卡借书(学校会发 书蛮多 我是基本没看过) 临近考试的时候 自习室人会很多</p><h3 id="食堂"><a href="#食堂" class="headerlink" title="食堂"></a>食堂</h3><p>学校有两个食堂 一个位于立志园 一个位于学校 (立业好像也有 我不大清楚 我住立志) 吃的不贵 </p><h3 id="学校周边"><a href="#学校周边" class="headerlink" title="学校周边"></a>学校周边</h3><ul><li>交通方便 有地铁 学校大门口就是公交站 </li><li>立志园大门 右边  <ol><li>物美超市 那边有个合作社 蛮多吃的 有个电影院  </li><li>垃圾街 小吃一条街 有个ktv</li><li>还有个艺术剧院 也是个电影院设施一般 离学校最近</li></ol></li><li>立志园大门 左边  <ol><li>文耀大厦 有个KTV 有个一点点  </li><li>宝龙(不知道是什么百度)</li></ol></li><li>再远一点  <ol><li>龙湖天街  </li><li>星光大道</li></ol></li></ul><h3 id="专升本"><a href="#专升本" class="headerlink" title="专升本"></a>专升本</h3><ul><li>专升本形式与高考差不多,但不是所有的学校都可以报考,只有部分院校有招生计划  </li><li>不可以跨专业报填,比如你是专科学应用电子专业,本科院校就只能是这个方向的有一定的限制,也没有那么死,应用电子也可以报考软件工程本科专业(具体参看下群文件去年的招生计划) </li><li>满分300 分文理<ol><li>文科 语文英语 各个150</li><li>理科 数学英语 各个150 </li></ol></li><li>学校会在大二下学期 统一开设补习班 想去就报名不贵(1000块忘记了) 也可以去外面的补习班(文亮之类的)  </li><li>个人觉得不是很难只要你肯学 考个二本公费不是很难 </li><li>群里有去年的专升本的招生计划 可以查阅下</li><li>我是没看过,希望你们不要给我浪费钱了   </li><li><a href="http://pan.baidu.com/s/1i5iqddr" target="_blank" rel="noopener">学习资料</a> </li></ul><h3 id="军训"><a href="#军训" class="headerlink" title="军训"></a>军训</h3><ul><li>新生9.15开学 17-28军训11天</li><li>军训服学校发(收费的)</li><li>要开枪自己带枪</li></ul><h3 id="生活费"><a href="#生活费" class="headerlink" title="生活费"></a>生活费</h3><ul><li>开学可以多带一点钱,3000吧 2000存支付宝 1000带现金(学校有些地方会用到).  </li><li>一般来说 我觉得1500一个月吃饭 偶尔出去出去一次 是够了 按自己的需求增加减少  </li></ul><h3 id="班级群"><a href="#班级群" class="headerlink" title="班级群"></a>班级群</h3><p>8月中的时候你们的班助会通过各种方式会联系到你的,不用管怎么联系到你,他肯定有方法,然后会把你们一个班的人拉到班级群里,然后关于一些专业上的问题,课多不多啊~什么的就可以问班助</p><h3 id="一些照片"><a href="#一些照片" class="headerlink" title="一些照片"></a>一些照片</h3><p><img src="http://imgsrc.baidu.com/forum/w%3D580%3B/sign=ce5bdf4497529822053339cbe7f17acb/5243fbf2b211931338061c3362380cd790238de8.jpg" alt="综合楼图" title="综合楼寝室图"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=a6aad4368b5494ee87220f111df4e0e1/7444b8096b63f6243e146c8a8044ebf81b4ca34d.jpg" alt="综合楼图" title="综合楼寝室图"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=634ecc275943fbf2c52ca62b807eca1e/015aa78b87d6277f3b3ddb1722381f30e924fc4a.jpg" alt="立志园" title="立志寝室图"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=f205d53ba118972ba33a00c2d6cd7b9d/290af5deb48f8c54b6fd2c0030292df5e0fe7f4a.jpg" alt="立志园" title="立志寝室图"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=e5d16d1fbb3533faf5b6932698d3fdca/b371c05c1038534307fb63309913b07eca808843.jpg" alt="立志园区" title="立志园区内图"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=d3a62622a2d3fd1f3609a232004e25ce/7da9b4119313b07e9bade50406d7912397dd8c01.jpg" alt="四人寝室" title="学校的部分四人寝"> </p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=77c43f97bf99a9013b355b3e2d970a58/141ed088d43f8794cc36abadd51b0ef419d53ac7.jpg" alt="校园照片" title="校园一角"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=f831876986cb39dbc1c0675ee01409a7/16b470c6a7efce1bb8e32b49a851f3deb68f65c0.jpg" alt="校园照片" title="&#39;校园一角"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=0c01208c8826cffc692abfba89014a7d/04d0a01ea8d3fd1ffa70f42f3a4e251f95ca5f01.jpg" alt="情人坡" title="情人坡"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=7d997a13efdde711e7d243fe97eecef4/c91126a4462309f738a96704780e0cf3d6cad6ba.jpg" alt="学校食堂" title="位于的学校食堂"> </p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=8913682f30292df597c3ac1d8c305ce2/707f6d600c338744f605827c5b0fd9f9d62aa04d.jpg" alt="学校食堂" title="位于立志的食堂"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=496fd51d9b8fa0ec7fc764051696594a/2d43912bd40735facd72599794510fb30e2408fc.jpg" alt="图书馆" title="图书馆"></p><p><img src="http://imgsrc.baidu.com/forum/w%3D580/sign=100ee90d43540923aa696376a259d1dc/a376d22a2834349b9e8479abc3ea15ce37d3befd.jpg" alt="图书馆" title="图书馆"></p><p><img src="http://group.store.qq.com/qun/V11wpw2x2HqPuL/V3tP1V9IpHLOFurJU4H/800?w5=640&amp;h5=1902&amp;rf=viewer_421" alt="校历" title="校历">  </p><ul><li><p><a href="http://tieba.baidu.com/p/5098294217?see_lz=1" target="_blank" rel="noopener">更多详情</a></p></li><li><p><a href="http://tieba.baidu.com/p/5733666583?see_lz=1" target="_blank" rel="noopener">更多详情(美女学姐版)</a></p></li></ul><h3 id="还需要什么"><a href="#还需要什么" class="headerlink" title="还需要什么"></a>还需要什么</h3><p>可以 新生群@孖 补充</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;学校&quot;&gt;&lt;a href=&quot;#学校&quot; class=&quot;headerlink&quot; title=&quot;学校&quot;&gt;&lt;/a&gt;学校&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;学校男女比例 3:7到4:6的样子,女孩子是多于男的  &lt;/li&gt;
&lt;li&gt;学校两个校区,统招是在滨江校区,成教是在德胜校区&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>laravel事件温习</title>
    <link href="http://yoursite.com/2018/06/29/laravel%E4%BA%8B%E4%BB%B6%E6%B8%A9%E4%B9%A0-zhengzhiyu/"/>
    <id>http://yoursite.com/2018/06/29/laravel事件温习-zhengzhiyu/</id>
    <published>2018-06-29T05:30:24.358Z</published>
    <updated>2018-06-29T05:30:01.689Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先说一下在什么场景会使用这个事件功能。<br>事情大概是这样的，需求要在用户注册的时候发一些帮助邮件给用户（原本用户在注册之后已经有发别的邮件的了，短信，IM什么的）<br>原来这个注册的方法也就10多行代码。但是有时候我们为了省事，直接在注册代码后面添加了各种代码。</p></blockquote><p>例如这个注册方法本来是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个需求，要求注册之后给用户的邮箱发一个广告，绝大多数的人（也包括以前的我）就直接在这后面接着写代码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        </span><br><span class="line">        //发送广告邮件</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是比较直观的写法，后来又有需求要发个短信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        </span><br><span class="line">        //发送广告邮件</span><br><span class="line">        //发送短信</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>然后又有需求，要发IM消息，这样的需求很多。这些方法如果你封装了，可能也就一行代码。<br>但是，在实际项目中，这个注册方法里面已经加了很多东西。如果多人开发的话各种不方便。然后想到了laravel似乎有这个功能，但是一直都不知道怎么应用，仔细看了一下手册，发现和自己的想法不谋而合。<br> laravel的事件功能实际上更倾向是一种管理手段，并不是没了它我们就做不到了，只是它能让我们做得更加好，更加优雅。<br>laravel的事件是一种管理+实现的体现，它首先有一个总的目录，然后我们可以宏观的看到所有的事件，而不需要每次都要打开控制器的方法我们才能知道注册后会发生什么，这一点很重要，非常的方便，我就不按着laravel的顺序来讲，而是按着实际情况来建立这种关系。<br>  现在我们无非就是要在注册之后要做一系列的事情，首先得注册完之后调用一个事件，然后这个事件再做各种各样的事</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line">//我们先引入一个事件类，名字自定义的，之后再一步一步创建</span><br><span class="line">use App\Events\Register;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        //触发事件，以后所有需要注册后要做的事情，都不需要再这里加代码了，我们只需要管理事件就好了</span><br><span class="line">        //event方法是laravel自带方法, $uid是外部参数，看你需要做什么，传什么参数了。注册之后肯定有$uid的嘛</span><br><span class="line">        event(new Register($uid));</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 找到\app\Providers\EventServiceProvider.php文件。给它添加关系，告诉系统，有人用event()调用了事件之后要被谁监听得到。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Providers;</span><br><span class="line"></span><br><span class="line">use Laravel\Lumen\Providers\EventServiceProvider as ServiceProvider;</span><br><span class="line"></span><br><span class="line">class EventServiceProvider extends ServiceProvider</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * The event listener mappings for the application.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected $listen = [</span><br><span class="line">        // 用户注册后的事件</span><br><span class="line">        &apos;App\Events\Register&apos; =&gt; [</span><br><span class="line">            // 发送广告邮件</span><br><span class="line">            &apos;App\Listeners\SendAdMail&apos;,</span><br><span class="line">            // 发送短信</span><br><span class="line">            &apos;App\Listeners\SendSms&apos;,</span><br><span class="line">            // 发送帮助信息</span><br><span class="line">            &apos;App\Listeners\SendHelpInformation&apos;,</span><br><span class="line"></span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里是注册事件的入口，相当于一个总目录，这样就可以跟注册代码解耦了，以后要加东西我们就不需要再去看注册方法的代码了<br>现在注册完之后会触发这个App\Events\Register类，然后这个类会被App\Listeners\SendAdMail,App\Listeners\SendSms，App\Listeners\SendHelpInformation监听得到，我们进入app\Events目录，创建Register这个类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Events;</span><br><span class="line"></span><br><span class="line">class Register</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public $uid;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新的事件实例.</span><br><span class="line">     *</span><br><span class="line">     * @param  Order  $order</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function __construct($uid)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;uid = $uid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了。</p><p>然后去app\Listeners目录创建各种要做的事件监听类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Listeners;</span><br><span class="line"></span><br><span class="line">use App\Events\Register;</span><br><span class="line">use App\Models\User;</span><br><span class="line">use Illuminate\Contracts\Queue\ShouldQueue;</span><br><span class="line"></span><br><span class="line">class SendHelpInformation implements ShouldQueue</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public function handle(Register $event)</span><br><span class="line">    &#123;</span><br><span class="line">        $uid = $event-&gt;uid;</span><br><span class="line">        </span><br><span class="line">        $user = User::find($uid);</span><br><span class="line">        </span><br><span class="line">        //......各种实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个handle方法就是我们要做的具体实现了，有个很方便的功能就是如果implements ShouldQueue这个接口的话就会异步队列执行，如果去掉的话就是同步执行。很方便有没有，这样代码就解耦了，不需要再管注册代码了，在这里就能很方便的管理了。多人开发也是单独写自己的Listeners就可以了。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;先说一下在什么场景会使用这个事件功能。&lt;br&gt;事情大概是这样的，需求要在用户注册的时候发一些帮助邮件给用户（原本用户在注册之后已经有发别的邮件的了，短信，IM什么的）&lt;br&gt;原来这个注册的方法也就10多行代码。但是有时候我们为了省事，直接在注册代码
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>大话设计模式笔记</title>
    <link href="http://yoursite.com/2018/06/26/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0-mabowen/"/>
    <id>http://yoursite.com/2018/06/26/大话设计模式笔记-mabowen/</id>
    <published>2018-06-26T08:18:17.342Z</published>
    <updated>2018-07-02T05:17:59.580Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>1.命名要规范<br>2.代码逻辑要规范</p><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>面向对象有三大特性:封装,继承和多态  </p><p>碰到问题就自觉得用计算机能理解得逻辑来描述和表达待解决的而问题及具体得求解过程,这样得思维缺使得外面得程序只为满足当前得需求,程序不容易维护,不容易拓展,不容易复用</p><p>面向对象的编程,并不是类越多越好,类的划分是为了封装,但分类的基础是抽象,具有相同的属性和功能的对象的抽象集合才是类</p><h4 id="面向对象得好处"><a href="#面向对象得好处" class="headerlink" title="面向对象得好处"></a>面向对象得好处</h4><p>通过封装,继承,多态把程序得耦合度降低,用设计模式使得程序更加得灵活,容易修改,易于复用.使得我们得代码更容维护,灵活性强,容易扩张和复用.</p><h4 id="业务的封装"><a href="#业务的封装" class="headerlink" title="业务的封装"></a>业务的封装</h4><p>编程有一原则,避免重复.<br>让业务与界面逻辑分开,让他们之间的耦合度下降,只有分离开,才可以达到维护或拓展.</p><h3 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h3><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>就一个类而言,应该仅有一个引起它变化的原因</p><p>遵循单一职责的优点:  </p><ul><li>降低了类的复杂度,一个类只负责一项职责  </li><li>提高了类的可读性,可维护性.</li><li>降低变更引起的风险</li></ul><h4 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h4><p>软件实体(类,模块,函数等等)应该是可以扩展,但是不可以修改.</p><p>开放-封闭原则是面向对象设计的核心所在.遵循这个原则可以带来面向对象技术所声称的巨大好处,也就是可维护,可扩展,可复用,灵活性好.开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象,然而,对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意,拒绝不成熟的抽象核抽象本身一样重要.</p><h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><p>高层模块不应该依赖于低层模块，二者都应该依赖其抽象；抽象不应该依赖于细节，细节应该依赖于抽象。因为相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构要比以细节为基础的架构要稳定的多。依赖倒置的中心思想是面向接口编程。上层模块不应该依赖于下层模块，应该依赖于接口。从而使得下层模块依赖于上层的接口，降低耦合度，提高系统的弹性。这六大原则是最虚，最抽象的，很难理解  </p><p>说白了就是针对接口编程,不要对实现编程</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>一个软件实体如果使用的是一个父类的话,那么一定适用于其子类,而且它察觉不出父类对象和子类对象的区别.也就是说,在软件里面,把父类都替换成它的子类,程序的行为没有变化  </p><p>只有当子类可以替换掉父类,软件单位的功能不受影响时,父类才能真正被复用,而子类也能够在父类的基础上增加的新的行为,正是由于子类型的可替换性才使得父类类型的模块在无需修改的情况下就可以拓展</p><h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p>如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用.如果其中一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用</p><p>迪米特法则其根本思想,是强调了类之间的松耦合<br>类之间的耦合越弱,越有利于复用,一个处于弱耦合的类被修改,不会对有关系的类造成波及</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式是面对对象多态性的一个应用,他的好处在于:</p><ul><li>代码具有一定拓展性</li><li>遵循了单一责任原则 </li><li>属于面向接口编程</li><li>简单工厂模式提供了一个对外的类Client和实际工作的类,外界只需要传递特定的参数就可以调用不同的实际功能类,而不需要直接面对实际类与函数,拓展性大大增加</li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>它定义了算法家族,分别封装起来,让它们之间可以互相替换,此模式让算法变化,不会影响到使用算法的客户,我们着重得到对象某方法的运行结果  </p><p>策略模式就是用来封装算法,在实践中,我们发现可以用它来封装几乎任何类型的规则,只要在分析过程中听见需要在不同时间应用不同的业务规则,就可以考虑使用策略模式处理</p><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>动态地给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成子类更为灵活</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>为其他对象提供一种代理以控制对这个对象的访问</p><ul><li>远程代理,也就是为一个对象在不同的地址空间提供局部代表.这样可以隐藏一个对象存在于不同地址空间的事实.</li><li>虚拟代理,是根据需要创建开销很大的对象.通过它来存放实例化需要很长时间的真实对象</li><li>安全代理,用来控制真实对象访问时和权限</li><li>智能指引,是指当调用真实的对象时,代理处理另一些事</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象  </p><p>原型模式其实就是一个对象再创建另一个可定制的对象,而且不需要知道任何创建的细节.</p><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>我们要完成在某一细节层次一致的一个过程或一系列步骤,但其个别步骤在更详细的层次上的实现可能不同时,我们通常考虑用模板方法模式处理</p><p>定义一个操作中的算法的骨架,而将一些步骤延迟到子类中,模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p><p>当不变的和可变的行为在方法的子类实现中混合在一起的时候,不变的行为就会在子类中重复出现.我们通过模板方法模式把这些行为搬移到单一的地方,这样就帮助子类摆脱重复的不变行为的纠缠</p><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更加容易使用</p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>将一个复杂对象的构建与它的表示分离,使得同样的构造过程可以创建不同的表示</p><p>建造者模式的好处就是使得建造代码与表示代码分离,由于建造者隐藏了该产品是如何组装的所以若需要改变一个产品的内部表示,只需要再定义一个具体的建造者就可以了</p><p>建造者模式实在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式适用 的模式</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>定义了一种一对多的依赖关系,让多个观察者对象同时监听某一个主题对象.这个主题对象在状态发生变化时,会通知所有观察者对象,使他们能够自动更新自己</p><p>观察者模式所做的工作其实就是在接触耦合,让耦合的双方都依赖于抽象,而不是依赖于具体.从而使得各自的变化都不会影响另一边的变化</p><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>提供一个创建一系列相关或相互依赖对象的接口,而无需指定他们具体的类 </p><p>好处 是易于交换产品系统</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><p>参考资料:<br>大话设计模式.pdf<br><a href="https://segmentfault.com/a/1190000005748456" target="_blank" rel="noopener">设计模式总汇总</a><br><a href="https://segmentfault.com/a/1190000015231632" target="_blank" rel="noopener">设计模式六大原则</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代码规范&quot;&gt;&lt;a href=&quot;#代码规范&quot; class=&quot;headerlink&quot; title=&quot;代码规范&quot;&gt;&lt;/a&gt;代码规范&lt;/h3&gt;&lt;p&gt;1.命名要规范&lt;br&gt;2.代码逻辑要规范&lt;/p&gt;
&lt;h3 id=&quot;面向对象&quot;&gt;&lt;a href=&quot;#面向对象&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker swarm</title>
    <link href="http://yoursite.com/2018/06/26/docker%E9%9B%86%E7%BE%A4%E7%AC%94%E8%AE%B0-chenhuaiyuan/"/>
    <id>http://yoursite.com/2018/06/26/docker集群笔记-chenhuaiyuan/</id>
    <published>2018-06-26T07:24:49.379Z</published>
    <updated>2018-06-26T07:25:05.376Z</updated>
    
    <content type="html"><![CDATA[<font style="float:right;">陈怀远</font>  <p><br><br>下面内容随便写的，想到什么就写什么，所以很凌乱，如果打算接触docker swarm 的可以看看，说不定对你有帮助，如有实在想不通的地方可以亲自问本人。  </p><p>当一个线上业务做到一定程度的时候，服务器过度负载的时候，就必须通过增加服务器来缓解另外服务器的压力，提高性能。 这个时候，问题来了，如何让多台服务器实现高可用呢？</p><p>答案就是集群，给所有服务器做集群。  </p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>在docker中我们可以用swarm。<br>首先我们准备至少两台服务器，拿其中的一台服务器作为leader，在这台服务器上运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line">// or</span><br><span class="line">docker swarm init --advertise-addr 192.168.x.x</span><br></pre></td></tr></table></figure><p>它会生成对应的token，类似于这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token \</span><br><span class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.x.x:2377</span><br></pre></td></tr></table></figure><p>如果你忘了leader上的token值，可以通过下面命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><p>这里有个需要注意的地方，不要忘了开启服务器对应的端口，docker swarm默认端口是2377</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>我们可以把刚刚生成的token放到另一台服务器里面，在另一台服务器执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token \</span><br><span class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.x.x:2377</span><br></pre></td></tr></table></figure><p>这个时候可以说我们的集群已经创好了，我们可以通过在leader服务器上运行<figure class="highlight docker"><figcaption><span>node ls``` 来查看</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 创建服务 </span></span><br><span class="line"></span><br><span class="line">接下来我们可以创建我们想要的服务，例如</span><br></pre></td></tr></table></figure></p><p>docker service create –name test –replicas 2 nginx:alpine<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然我们也可以通过docker compose来创建服务，我们可以自己写一个docker-compose.yml文件，例如：</span><br></pre></td></tr></table></figure></p><p>version: ‘3.2’<br>services:<br>  php-fpm:<br>    image: php:fpm-alpine<br>    volumes:</p><pre><code>  - ./html:/data/www/htmlcontainer_name: php-fpm</code></pre><p>  nginx:<br>    image: nginx:alpine<br>    volumes:</p><pre><code>  - ./nginx.cnf:/etc/nginx/conf.d  - ./html:/data/www/htmlports:  - &quot;80:80&quot;container_name: nginx</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里需要注意的是docker compose只有版本3才支持swarm,还有就是volumes所对应的目录必须在另一台服务器上也有，要不然会出现两个应用容器都装在leader服务器上，再需要注意的是两台服务器上必须都要有相对应的容器镜像，要不然会创建失败，我们可以通过</span><br><span class="line">```docker compose pull``` 来拉取</span><br><span class="line"></span><br><span class="line">这些工作做完之后我们就可以部署了，命令如下</span><br></pre></td></tr></table></figure><p>docker stack deploy -c docker-compose.yml test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它会自动把两个容器部署到两台服务器上，让人感觉就像是在一台服务器上一样。  </span><br><span class="line">注意：在创建集群的时候最好是内网服务器集群，不要用不同网络的，不同网络会出现另一台服务器部署失败  </span><br><span class="line"></span><br><span class="line">我们可以通过scale来修改容器数量</span><br></pre></td></tr></table></figure></p><p>docker service scale service_name=2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它会自动部署到服务器上</span><br><span class="line"></span><br><span class="line">它默认会自动创建一个网络，如果想要自己定义，可以在docker compose里面定义</span><br><span class="line"></span><br><span class="line">### 删除服务</span><br><span class="line"></span><br><span class="line">如果我们想要删除服务可以运行以下命令</span><br></pre></td></tr></table></figure></p><p>docker service rm service_name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 脱离集群</span><br><span class="line"></span><br><span class="line">如果我们想要脱离集群，我们可以运行以下命令：</span><br></pre></td></tr></table></figure></p><p>docker swarm leave<br>// or<br>docker swarm leave –force<br><code>`</code></p><p>这里说一点，最新版的 Swarm 提供自动服务发现与集群负载功能。</p><p>关于docker swarm，我就先写那么多。如有时间，再完善。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font style=&quot;float:right;&quot;&gt;陈怀远&lt;/font&gt;  

&lt;p&gt;&lt;br&gt;&lt;br&gt;下面内容随便写的，想到什么就写什么，所以很凌乱，如果打算接触docker swarm 的可以看看，说不定对你有帮助，如有实在想不通的地方可以亲自问本人。  &lt;/p&gt;
&lt;p&gt;当一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://yoursite.com/2018/06/26/http%E5%93%8D%E5%BA%94%E7%A0%81-mabowen/"/>
    <id>http://yoursite.com/2018/06/26/http响应码-mabowen/</id>
    <published>2018-06-26T00:46:50.088Z</published>
    <updated>2018-06-26T00:59:16.941Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>200s:请求被接受,并且服务器没有发生错误</p></li><li><p>300s:重定向 </p></li><li><p>400s:客户端错误<br>一般来说是指请求出现问题,这可能是浏览器原因,或者是使用得url有问题</p></li><li><p>401s:未授权</p></li><li><p>403s:禁止访问</p></li><li><p>404s:不确定这个资源是否存在</p></li><li><p>407s:需要代理服务器授权</p></li><li><p>408s:超时</p></li><li><p>409s:冲突  </p></li><li><p>410s:这是一种资源曾经存在的情况，但已被永久删除，并且不会返回。 如果您从网站上永久删除了一个页面，则应该使用 410，而不是 404。</p></li><li><p>500s:服务器错误</p></li><li><p>502s:网关错误</p></li><li><p>503s:服务暂时不可用</p></li><li><p>504s:网关超时</p></li></ul><p>详情:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP响应码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;200s:请求被接受,并且服务器没有发生错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;300s:重定向 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;400s:客户端错误&lt;br&gt;一般来说是指请求出现问题,这可能是浏览器原因,或者是使用得url有问题&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Markdown 语法手册</title>
    <link href="http://yoursite.com/2018/06/13/markdown%E6%89%8B%E5%86%8C-mabowen/"/>
    <id>http://yoursite.com/2018/06/13/markdown手册-mabowen/</id>
    <published>2018-06-13T08:34:29.897Z</published>
    <updated>2018-06-26T07:25:29.427Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 可以嵌套html</p><h3 id="斜体与粗体"><a href="#斜体与粗体" class="headerlink" title="斜体与粗体"></a>斜体与粗体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.*斜体*或者_斜体_</span><br><span class="line">2.**粗体**</span><br><span class="line">3.***加粗斜体***</span><br><span class="line">4.~~删除线~~</span><br></pre></td></tr></table></figure><h4 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果:"></a>显示效果:</h4><ul><li><em>这是一段斜体</em></li><li><strong>这是一段粗体</strong></li><li><strong><em>这是一段加粗斜体</em></strong></li><li><del>这是一段删除线</del></li></ul><h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法:"></a>第一种写法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.这是一个一级标题</span><br><span class="line">2.================</span><br><span class="line">3.</span><br><span class="line">4.这是一个二级标题</span><br><span class="line">5.----------------</span><br></pre></td></tr></table></figure><h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法:"></a>第二种写法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.# 一级标题</span><br><span class="line">2.## 二级标题</span><br><span class="line">3.### 三级标题</span><br><span class="line">4.#### 四级标题</span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="Markdown-支持两种形式的超链接语法-行内式与参考式"><a href="#Markdown-支持两种形式的超链接语法-行内式与参考式" class="headerlink" title="Markdown 支持两种形式的超链接语法:行内式与参考式"></a>Markdown 支持两种形式的超链接语法:行内式与参考式</h4><h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明:"></a>语法说明:</h4><ul><li><h5> []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<a href="链接地址 “链接标题”">链接文字</a>这样的形式。链接地址与链接标题前有一个空格。</h5></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.[百度](&apos;https://www.baidu.com/&apos;)</span><br><span class="line">2.[百度](&apos;https://www.baidu.com/&apos;&quot;百度&quot;)</span><br></pre></td></tr></table></figure><p>显示效果<br> <a href="&#39;https://www.baidu.com/&#39;">百度</a><br> <a href="&#39;https://www.baidu.com/&#39;&quot;百度&quot;">百度</a></p><h4 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h4><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]</span><br><span class="line">2.[Leanote 笔记][2]是一个不错的[网站][]。</span><br><span class="line">3. [1]:http://www.google.com &quot;Google&quot;</span><br><span class="line">4. [2]:http://www.leanote.com &quot;Leanote&quot;</span><br><span class="line">5. [3]:http://http://blog.leanote.com/freewalk &quot;梵居闹市&quot;</span><br><span class="line">6. [网站]:http://http://blog.leanote.com/freewalk</span><br></pre></td></tr></table></figure><p>显示效果:<br>我经常去的几个网站<a href="http://www.google.com" title="Google" target="_blank" rel="noopener">Google</a>、<a href="http://www.leanote.com" title="Leanote" target="_blank" rel="noopener">Leanote</a>以及<a href="http://http://blog.leanote.com/freewalk" title="梵居闹市" target="_blank" rel="noopener">自己的博客</a><br><a href="http://www.leanote.com" title="Leanote" target="_blank" rel="noopener">Leanote 笔记</a>是一个不错的<a href="http://http://blog.leanote.com/freewalk" target="_blank" rel="noopener">网站</a>。</p><h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><h5 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明:"></a>语法说明:</h5><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接[目录]。一般网址的链接文字就和链接地址一样，例如：<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;www.baidu.com&gt;</span><br><span class="line">2.&lt;610286632@qq.com&gt;</span><br></pre></td></tr></table></figure><p>显示效果<br><a href="http://baidu.com/" target="_blank" rel="noopener">http://baidu.com/</a><br><a href="mailto:&#x36;&#49;&#x30;&#x32;&#x38;&#54;&#x36;&#x33;&#50;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#109;" target="_blank" rel="noopener">&#x36;&#49;&#x30;&#x32;&#x38;&#54;&#x36;&#x33;&#50;&#x40;&#113;&#113;&#46;&#x63;&#x6f;&#109;</a></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用*,+,-表示无序列表.<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. - 无序列表</span><br><span class="line">2. + 无序列表</span><br><span class="line">3. * 无序列表</span><br></pre></td></tr></table></figure><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表则使用数字接着一个英文句点。<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项 </span><br><span class="line">2. 有序列表项 </span><br><span class="line">3. 有序列表项</span><br></pre></td></tr></table></figure><p>显示效果:  </p><ol><li>有序列表项  </li><li>有序列表项   </li><li>有序列表项 </li></ol><h4 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h4><p>语法说明:<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Markdown</span><br><span class="line">:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line">代码块 2</span><br><span class="line">:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line">        代码块（左侧有八个不可见的空格）</span><br></pre></td></tr></table></figure><p>显示效果<br>Markdown<br>:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>语法说明:<br>引用需要在被引用的文本前加上&gt;符号<br>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*   阅读的方法:</span><br><span class="line"></span><br><span class="line">&gt; 1.   这是第一行列表项。</span><br><span class="line">&gt; 2.   这是第二行列表项。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 给出一些例子代码：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br><span class="line"></span><br><span class="line">允许偷懒只在整个段落前第一行加上&gt;:</span><br><span class="line">&gt; 打开书本</span><br><span class="line">打开电灯</span><br></pre></td></tr></table></figure><p>显示效果:</p><blockquote><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;); </code></pre></blockquote><p>允许偷懒只在整个段落前第一行加上&gt;:</p><blockquote><p>打开书本<br>打开电灯</p></blockquote><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">行内式:</span><br><span class="line">美丽花儿： </span><br><span class="line">![美丽花儿](http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg &quot;美丽花儿&quot;)</span><br><span class="line"></span><br><span class="line">参考式  </span><br><span class="line">美丽花儿：</span><br><span class="line">![美丽花儿][flower]</span><br><span class="line">[flower]:http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg  &quot;美丽花儿&quot;</span><br></pre></td></tr></table></figure><p>显示效果:<br>行内式<br>美丽花儿：<br><img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p><h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><p>语法说明：<br>在需要添加注脚的文字后加上脚注名字称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。<br>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line"></span><br><span class="line">[^1]:Markdown是一种纯文本标记语言</span><br><span class="line"></span><br><span class="line">[^2]:HyperText Markup Language 超文本标记语言</span><br><span class="line"></span><br><span class="line">[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure><p>显示效果:<br>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。</p><p>[^2]:HyperText Markup Language 超文本标记语言</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>显示效果都一样：</p><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Markdown 可以嵌套html&lt;/p&gt;
&lt;h3 id=&quot;斜体与粗体&quot;&gt;&lt;a href=&quot;#斜体与粗体&quot; class=&quot;headerlink&quot; title=&quot;斜体与粗体&quot;&gt;&lt;/a&gt;斜体与粗体&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git学习</title>
    <link href="http://yoursite.com/2018/06/13/git%E5%AD%A6%E4%B9%A0-mabowen/"/>
    <id>http://yoursite.com/2018/06/13/git学习-mabowen/</id>
    <published>2018-06-13T08:34:29.886Z</published>
    <updated>2018-07-02T06:53:22.415Z</updated>
    
    <content type="html"><![CDATA[<p>参照 廖雪峰git教程 原文-<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">git教程</a></p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>什么是版本库,可以理解为成一个目录,目录的所有文件都可以被git管理起来,每个文件的修改,删除,git都能跟踪,以便任何时刻可以追踪到历史,或者在将来某个时刻可以还原.<br>创建版本库非常简单,首先,选择一个合适的地方,创建一个空目录:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mabowen (创建文件夹)</span><br><span class="line">$ cd mabowen </span><br><span class="line">$ pwd 显示路径</span><br></pre></td></tr></table></figure><p>注意:windows系统目录名不包含中文<br>通过git init命令可以把这个目录变成git可以管理的仓库:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in E:/mabowen/.git/</span><br></pre></td></tr></table></figure><p>编写一个readme.txt文件 一定要放在自己所创建的目录下 git才能找到<br>第一步,用git add把文件添加到仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>没有消息提示是正确的</p><p>第二步,用git commit告诉git,把文件提交到仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m&apos;test&apos;</span><br><span class="line">[master (root-commit) 12ee85d] test</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></p><p>-m后面输入的是本次提交的内容,最好是有意义的,下次可以从历史记录中找到改动记录  </p><ul><li>1 file changed 一个文件被改动  </li><li>2 insertions 插入了两条内容  </li></ul><p>git add 可以 添加很多文件<br>git commit -m 可以一次性全部提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add test1.txt test2.txt</span><br><span class="line">$ git commit -m&apos;test&apos;</span><br></pre></td></tr></table></figure><h3 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h3><p>git status 命令可以告诉我们当前的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>上面的命令告诉我们 readme.txt 被修改过但是还没准备提交的修改  </p><p>git diff可以查看不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p>可以看到我们在第一行添加了 distributed 单词<br>接着在执行 git add 在 git commit 之前再运行 git status 查看当前仓库的状态<br>提交后,在用git status 查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>git 告诉我们当前没有需要修改的地方,而且工作目录是干净的</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>git log 命令可以查看历史记录, 我们可以看见最近的提交 如果嫌输出信息太多,可以加 –pretty=oneline  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">a922e70b941dbdb2bacaa9cf4ba35ad8bdeee8c3 (HEAD -&gt; master) test</span><br><span class="line">12ee85d9bfdaeed13bd6dfa85f911b0cbad0849a test</span><br></pre></td></tr></table></figure><blockquote><p>a992这一串是commit id 是(版本号)首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交a992(注意我的提交ID和你的肯定不一样)，上一个版本就是HEAD^  ，上上一个版本就是HEAD^^ ,当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100</p></blockquote><p>如果要回退到上一个版本 就可以用 git reset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 12ee85d test</span><br></pre></td></tr></table></figure><p>如果想回去 找到commit id 就可以回去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard a922</span><br><span class="line">HEAD is now at a922e70 test</span><br></pre></td></tr></table></figure><p>版本号可以不用写全,git可以自己去找,当然也不能只写一两位,因为,git可以找到多个版本就无法确定是哪一个.<br>git的版本回退速度非常快,因为git在内部有个指向当前版本的HEAD指针,当你回退版本的时候,git就只是把HEAD指针指向那个版本</p><p>小结  </p><ul><li><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p></li><li><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p></li><li><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p></li></ul><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>工作区<br>就是你电脑能看见的目录是一个工作区<br>版本库<br>工作区有一个隐藏的.git,这个不算工作区,而是git的版本库.<br>git add 把文件添加到暂存区<br>git commit 提交更改 相当于把暂存区的所有内容提交当前分支<br>一旦提交后,如果你又没有对工作区做任何修改,那么工作区就是干净的  </p><p>管理修改<br>第一次修改-&gt;git add-&gt;第二次修改-&gt;git commit<br>当你第一次git add 命令提交了 在工作区第一次修改放入暂存区,准备提交,但是工作区的第二次修改并没有放入暂存区,所以git commit 只是把暂存区的修改提交了,也就是第一次修改提交了,第二次修改没有提交</p><p>那么如何提交二次修改呢<br>第一次修改-&gt;git add-&gt;第二次修改-&gt;git add-&gt;git commit<br>如果每次修改不用git add 放到暂存区就不会加入commit中</p><p>撤销修改<br>git chekout –file 可以丢弃工作区的修改  把file在工作区的修改全部撤销,这里有两种情况  </p><ul><li>一种文件修改后还没有被放到暂存区,现在,撤销修改就回到和版本库一摸一样的状态;  </li><li>一种文件已经添加到暂存区后,又做了修改,现在,撤销修改就回到添加到暂存区后的状态.<br>总之就是让这个文件回到最近一次 git commit 或 git add 时的状态</li></ul><p>git reset HEADfile 可以把暂存区的修改撤销掉,重新放回工作区:  </p><p>小结</p><ul><li>场景一:当你改乱工作区某一个文件的内容,想直接丢弃工作区的修改时候,用git chekout – file</li><li>场景二:当你不但该乱了工作区某个文件的内容,还添加到暂存区,想丢弃修改,分两步 第一步 用git reset HEAD file 回到场景一 第二步按场景一操作  </li><li>已经提交了不合适的修改到版本库想撤销本次提交,可以用版本回退一节,前提是没有推送到远端库  </li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>一般情况下你通常直接把没用的文件删了,这时候git知道你删除了文件,工作区和版本库就不一致了,git status 命令告诉你哪些文件被删除了<br>这时候,你有两个选择  </p><ul><li>从版本库中删除该文件,哪就用命令git rm 删除,并且git commit</li><li>另一种是删错了,因为版本库还有,可以轻松的把文件恢复到最新版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h3 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h3><p>在看分支管理前,首先明确工作区和暂存区的概念,以及各种命令的用法,以及commit是加到暂存区这类的概念问题</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>在每次提交,git都把他们串成一条时间线,这条时间线就是一个分支,只有一条时间线,在git里这个分支叫主分支,即master分支.HEAD严格来说不是指向提交,而是指向master,master才是指向提交的,所以,HEAD指向确定当前分支.<br>也就是说是master 指向版本 HEAD去指向你是处于什么分支<br>每次提交master分支都会向前一步,这样随你不断的提交,master分支的线越来越长.<br>当我们创建新的分支,比如我们创建一个mabowen的分支基于master,再把HEAD指向mabowen就表示当前分支在mabowen上 现在开始对工作区的提交和修改都是在mabowen分支上开发,每一次新的提交,mabowen指针往前一步,而master指针不变</p><p>小结  </p><ul><li>查看分支：git branch</li><li>创建分支：git branch <name>  </name></li><li>切换分支：git checkout <name></name></li><li>创建+切换分支：git checkout -b <name></name></li><li>合并某分支到当前分支：git merge <name></name></li><li>删除分支：git branch -d <name></name></li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>当git无法自动合并分支时,就必须首先解决冲突.解决冲突以后,在提交,合并完成.<br>解决冲突就是把git合并失败的文件手动编辑为我们希望的内容,在提交.<br>用git log –graph可以查看分支合并图    </p><blockquote><p>以上是个人理解 有些不足 可以看廖雪峰git的教程 更加完善 </p></blockquote><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><p>git提供了一个git stash功能 可以把当前的工作现场储藏起来等以后恢复现场后继续工作</p><blockquote><p>详细见原教程</p></blockquote><h3 id="多人开发"><a href="#多人开发" class="headerlink" title="多人开发"></a>多人开发</h3><p>当你从远端克隆时,实际上git自动把本地的master分支和远程的matser 分支对应起来了,并且,远程仓库的默认名称是origin.    </p><p>要查看远端库的信息,用git remote 命令</p><p>或者,用git remote -v 显示跟详细的信息 </p><p>上面显示可以抓取和推送的origin的地址,如果没有推送权限就看不到push地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>推送分支 </p><p>推送分支,就是把该分支上所有本地提交推送到远程库.推送时,要指定本地分支,这样,git就会把分支推送到远程库对应的远程分支上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支,比如dev,就改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git push origin dev</span><br></pre></td></tr></table></figure><p>抓取分支<br>多人协作时,大家都会往master和dev分支上推送各自的修改.<br>现在,模拟一个你的小伙伴,可以在另一个电脑,或者同一个电脑的另一个目录下克隆:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &apos;learngit&apos;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure><p>当你从远程库clone时，默认情况下，你只能看到本地的master分支。不信可以用git branch命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在你要在dev分支上开发,就必须创建远端origin的dev分支到本地,于是你可以用这个命令创建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>然后他就可以在dev上继续修改,然后,可以push到远程  </p><p>当我们本地的master分支落后于远端的master分支时候一个提交时候 这时你上传到远端就上传不上去,需要先从远端pull下代码 这时就可能会引起冲突,原因可能是因为你本地的代码与远端的pull下的代码有共同修改的地方 </p><p>这时候需要解决冲突</p><p>因此，多人协作的工作模式通常是这样：</p><p>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></p><p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><ul><li><p>reabse操作可以把本地未push的分支提交历史整理成直线;</p></li><li><p>rebase的目的是使得我们在查看历史提交的变化更容易,因为分叉提交需要三方那对比</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参照 廖雪峰git教程 原文-&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git经验之谈</title>
    <link href="http://yoursite.com/2018/06/13/git%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88-chenhuaiyuan/"/>
    <id>http://yoursite.com/2018/06/13/git经验之谈-chenhuaiyuan/</id>
    <published>2018-06-13T08:34:29.878Z</published>
    <updated>2018-07-02T06:58:52.453Z</updated>
    
    <content type="html"><![CDATA[<font style="float:right;">陈怀远</font>  <p><font size="0px"><br>git是一个代码管理工具，一般用于团队开发协作。git的使用方法我就不说了，主要说说git的使用技巧。</font></p><h2 id="如何轻易记住命令"><a href="#如何轻易记住命令" class="headerlink" title="如何轻易记住命令"></a>如何轻易记住命令</h2><p>  在你使用git的时候，一般你很难记住git命令，尤其是刚学习的时候。那怎么样才能让我们更好的记住git命令呢，这里我推荐两个方法。  </p><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>  当你安装了git之后，在你的用户目录下面会有一个.gitconfig文件，你可以在这个文件里面加入alias标签，顾名思义，就是给git取个别名，取一个你熟悉的名字，这样你就能记住这个命令了，下面我将给出我的别名配置。  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">        s = status --short --branch</span><br><span class="line">        ss = status</span><br><span class="line">        brd = branch -D</span><br><span class="line">        brm = branch -m</span><br><span class="line">        br = branch</span><br><span class="line">        bra = branch --all</span><br><span class="line">        ci = commit</span><br><span class="line">        cim = commit -m</span><br><span class="line">        cia = commit -a</span><br><span class="line">        co = checkout</span><br><span class="line">        cob = checkout -b</span><br><span class="line">        fe = fetch origin</span><br><span class="line">        fp = fetch origin -p</span><br><span class="line">        last = log -1 HEAD</span><br><span class="line">        unstage = reset HEAD --</span><br><span class="line">        lg = &quot;log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative&quot;</span><br><span class="line">        mg = merge --squash --no-commit</span><br><span class="line">        pl = pull</span><br><span class="line">        plo = pull origin</span><br><span class="line">        ph = push</span><br><span class="line">        pho = push origin</span><br><span class="line">        df = diff</span><br><span class="line">        stl = stash list</span><br><span class="line">        st = stash</span><br><span class="line">        stp = stash pop</span><br><span class="line">        sta = stash apply</span><br><span class="line">        sts = stash save</span><br><span class="line">        stc = stash clear</span><br><span class="line">        rb = rebase</span><br><span class="line">        rba = rebase --abort</span><br><span class="line">        rec = rebase --continue</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>  修改你的shell配置文件，你可以在命令行输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $SHELL</span><br></pre></td></tr></table></figure><p>查看你当前使用的shell，我用的是zsh，如果你使用的是bash，最好用版本4.0以上的，因为好像只用4.0及以上才能使用alias。你可以在用户目录下面找到相应的配置文件，我的是.zshrc, 如果是bash，配置文件应该是.bashrc。打开配置文件。你可以在配置文件最后加上以下代码。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alias pull=&quot;git pull&quot;</span><br><span class="line">alias push=&quot;git push&quot;</span><br><span class="line">alias st=&quot;git status&quot;</span><br><span class="line">alias g=&quot;git&quot;</span><br></pre></td></tr></table></figure><p>  你可以按照你自己的习惯来取自己喜欢的别名，当你添加完别名后只需要重启终端就可以使用了。</p><h2 id="开发上的建议"><a href="#开发上的建议" class="headerlink" title="开发上的建议"></a>开发上的建议</h2><p>  永远不要在master分支上开发，为了不污染分支，我个人的建议是创建一个个人分支，在个人分支上进行开发，当要提交代码的时候就把自己的分支和要提交的分支合并。这样做的好处，你可以清晰的知道自己在干什么，可以让你避免不必要的麻烦。<br>  在提交代码的时候，一定要先pull一下代码，这是必须的，因为我们无法知道线上的分支和自己的分支指针是不是一样的。当然，如果你没pull然后提交出现了无法提交问题也是可以解决的，这个时候我们可以使用rebase来同步分支的指针。当然，当你提交完后最好把本地的当前分支删除，重新从线上拉取。</p><p>  编写未完，后期补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;font style=&quot;float:right;&quot;&gt;陈怀远&lt;/font&gt;  

&lt;p&gt;&lt;font size=&quot;0px&quot;&gt;&lt;br&gt;git是一个代码管理工具，一般用于团队开发协作。git的使用方法我就不说了，主要说说git的使用技巧。&lt;/font&gt;&lt;/p&gt;
&lt;h2 id=&quot;如何轻易
      
    
    </summary>
    
    
  </entry>
  
</feed>
