<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>写给新生</title>
      <link href="/2018/07/01/%E5%86%99%E7%BB%99%E6%96%B0%E7%94%9F/"/>
      <url>/2018/07/01/%E5%86%99%E7%BB%99%E6%96%B0%E7%94%9F/</url>
      <content type="html"><![CDATA[<h3 id="学校"><a href="#学校" class="headerlink" title="学校"></a>学校</h3><ul><li>学校占地面积是 500多亩 别问大不大 这主观性太强 (个人觉得不是太大) 大不大你自己看 </li><li>大一学校活动也蛮多 很多晚会 (需要抢票)  还有很多社团(我没有参加过 不大清楚)</li><li>大一大部分同学是有早晚自修(应该是都要)</li><li>学校离垃圾街不远(小吃街) 离 <strong>立业园</strong> (学校的一个寝室园区)很近</li><li>寝室园区会有很多收快递的站点 不用担心自己上课 不方便收快递</li><li>学校有三种wifi<br>1.移动的 要有移动账号<br>2.电信的 要有电信账号(这个是有在寝室园区搜的到)<br>3.zjbc 学校提供的(这个只有学校里面搜的到)</li></ul><h3 id="宿舍"><a href="#宿舍" class="headerlink" title="宿舍"></a>宿舍</h3><ul><li>六人寝室</li><li>不是上床下桌 (因为是六人 有两张床铺是上床下桌)</li><li>有空调(和室友一起合租一个 用三年费用大概是300上下 毕业有退100上下 保存好合同)</li><li>有独卫里面有个蹲坑 有个淋浴(时间段的提供热水) 有面镜子 有个洗漱台</li><li>床上用品可以自己带 具体大小和你高中的应该是一样的(详情贴吧找找吧 忘记了)</li><li>有饮水机(自己租 多少忘记了 不贵)</li><li>寝室可以装一个WiFi买个路由器(用自己的移动账号可以 不会装找会装的人   <strong>电信账号不能用于路由器!!!</strong>)</li><li>宿舍照片 贴吧很容易找到 自己可以翻一番</li><li>学校有三个寝室楼 <ol><li>大部分学生是住在 <strong>立志园</strong>  </li><li>部分学院的女生(只能是女生 <strong>这个不是水泥地</strong> ) 可以住在位于学校里面的 <strong>综合楼</strong> </li><li>一小部分住在 <strong>立业园</strong> </li></ol></li></ul><h3 id="图书馆"><a href="#图书馆" class="headerlink" title="图书馆"></a>图书馆</h3><p>学校的图书馆位于学校里面 有两个自修室 可以用自己的校卡借书(学校会发 书蛮多 我是基本没看过) 临近考试的时候 自习室人会很多</p><h3 id="食堂"><a href="#食堂" class="headerlink" title="食堂"></a>食堂</h3><p>学校有两个食堂 一个位于立志园 一个位于学校 (立业好像也有 我不大清楚 我住立志) 吃的不贵 </p><h3 id="学校周边"><a href="#学校周边" class="headerlink" title="学校周边"></a>学校周边</h3><ul><li>交通方便 有地铁 学校大门口就是公交站 </li><li>立志园大门 右边  <ol><li>物美超市 那边有个合作社 蛮多吃的 有个电影院  </li><li>垃圾街 小吃一条街 有个ktv</li><li>还有个艺术剧院 也是个电影院设施一般 离学校最近</li></ol></li><li>立志园大门 左边  <ol><li>文耀大厦 有个KTV 有个一点点  </li><li>宝龙(不知道是什么百度)</li></ol></li><li>再远一点  <ol><li>龙湖天街  </li><li>星光大道</li></ol></li></ul><h3 id="专升本"><a href="#专升本" class="headerlink" title="专升本"></a>专升本</h3><ul><li>满分300 分文理<ol><li>文科 语文英语 各个150</li><li>理科 数学英语 各个150 </li></ol></li><li>学校会在大二下学期 统一开设补习班 想去就报名不贵(1000块忘记了) 也可以去外面的补习班(文亮之类的)  </li><li>个人觉得不是很难只要你肯学 考个二本公费不是很难 </li><li>群里有去年的专升本的招生计划 可以查阅下</li><li>我是没看过,希望你们不要给我浪费钱了   </li><li><a href="http://pan.baidu.com/s/1i5iqddr" target="_blank" rel="noopener">学习资料</a> </li></ul><h3 id="还需要什么"><a href="#还需要什么" class="headerlink" title="还需要什么"></a>还需要什么</h3><p>可以 新生群@学长 补充</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>laravel事件温习</title>
      <link href="/2018/06/29/laravel%E4%BA%8B%E4%BB%B6%E6%B8%A9%E4%B9%A0-zhengzhiyu/"/>
      <url>/2018/06/29/laravel%E4%BA%8B%E4%BB%B6%E6%B8%A9%E4%B9%A0-zhengzhiyu/</url>
      <content type="html"><![CDATA[<blockquote><p>先说一下在什么场景会使用这个事件功能。<br>事情大概是这样的，需求要在用户注册的时候发一些帮助邮件给用户（原本用户在注册之后已经有发别的邮件的了，短信，IM什么的）<br>原来这个注册的方法也就10多行代码。但是有时候我们为了省事，直接在注册代码后面添加了各种代码。</p></blockquote><p>例如这个注册方法本来是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个需求，要求注册之后给用户的邮箱发一个广告，绝大多数的人（也包括以前的我）就直接在这后面接着写代码了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        </span><br><span class="line">        //发送广告邮件</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是比较直观的写法，后来又有需求要发个短信。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        </span><br><span class="line">        //发送广告邮件</span><br><span class="line">        //发送短信</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p>然后又有需求，要发IM消息，这样的需求很多。这些方法如果你封装了，可能也就一行代码。<br>但是，在实际项目中，这个注册方法里面已经加了很多东西。如果多人开发的话各种不方便。然后想到了laravel似乎有这个功能，但是一直都不知道怎么应用，仔细看了一下手册，发现和自己的想法不谋而合。<br> laravel的事件功能实际上更倾向是一种管理手段，并不是没了它我们就做不到了，只是它能让我们做得更加好，更加优雅。<br>laravel的事件是一种管理+实现的体现，它首先有一个总的目录，然后我们可以宏观的看到所有的事件，而不需要每次都要打开控制器的方法我们才能知道注册后会发生什么，这一点很重要，非常的方便，我就不按着laravel的顺序来讲，而是按着实际情况来建立这种关系。<br>  现在我们无非就是要在注册之后要做一系列的事情，首先得注册完之后调用一个事件，然后这个事件再做各种各样的事</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Htt\Controllers;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line">//我们先引入一个事件类，名字自定义的，之后再一步一步创建</span><br><span class="line">use App\Events\Register;</span><br><span class="line"></span><br><span class="line">class UserController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        //获取参数</span><br><span class="line">        //验证参数</span><br><span class="line">        //写入数据库</span><br><span class="line">        //触发事件，以后所有需要注册后要做的事情，都不需要再这里加代码了，我们只需要管理事件就好了</span><br><span class="line">        //event方法是laravel自带方法, $uid是外部参数，看你需要做什么，传什么参数了。注册之后肯定有$uid的嘛</span><br><span class="line">        event(new Register($uid));</span><br><span class="line">        //return 注册信息</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 找到\app\Providers\EventServiceProvider.php文件。给它添加关系，告诉系统，有人用event()调用了事件之后要被谁监听得到。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Providers;</span><br><span class="line"></span><br><span class="line">use Laravel\Lumen\Providers\EventServiceProvider as ServiceProvider;</span><br><span class="line"></span><br><span class="line">class EventServiceProvider extends ServiceProvider</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * The event listener mappings for the application.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected $listen = [</span><br><span class="line">        // 用户注册后的事件</span><br><span class="line">        &apos;App\Events\Register&apos; =&gt; [</span><br><span class="line">            // 发送广告邮件</span><br><span class="line">            &apos;App\Listeners\SendAdMail&apos;,</span><br><span class="line">            // 发送短信</span><br><span class="line">            &apos;App\Listeners\SendSms&apos;,</span><br><span class="line">            // 发送帮助信息</span><br><span class="line">            &apos;App\Listeners\SendHelpInformation&apos;,</span><br><span class="line"></span><br><span class="line">        ],</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里是注册事件的入口，相当于一个总目录，这样就可以跟注册代码解耦了，以后要加东西我们就不需要再去看注册方法的代码了<br>现在注册完之后会触发这个App\Events\Register类，然后这个类会被App\Listeners\SendAdMail,App\Listeners\SendSms，App\Listeners\SendHelpInformation监听得到，我们进入app\Events目录，创建Register这个类</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Events;</span><br><span class="line"></span><br><span class="line">class Register</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public $uid;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建一个新的事件实例.</span><br><span class="line">     *</span><br><span class="line">     * @param  Order  $order</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function __construct($uid)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;uid = $uid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以了。</p><p>然后去app\Listeners目录创建各种要做的事件监听类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Listeners;</span><br><span class="line"></span><br><span class="line">use App\Events\Register;</span><br><span class="line">use App\Models\User;</span><br><span class="line">use Illuminate\Contracts\Queue\ShouldQueue;</span><br><span class="line"></span><br><span class="line">class SendHelpInformation implements ShouldQueue</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        //</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    public function handle(Register $event)</span><br><span class="line">    &#123;</span><br><span class="line">        $uid = $event-&gt;uid;</span><br><span class="line">        </span><br><span class="line">        $user = User::find($uid);</span><br><span class="line">        </span><br><span class="line">        //......各种实现</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个handle方法就是我们要做的具体实现了，有个很方便的功能就是如果implements ShouldQueue这个接口的话就会异步队列执行，如果去掉的话就是同步执行。很方便有没有，这样代码就解耦了，不需要再管注册代码了，在这里就能很方便的管理了。多人开发也是单独写自己的Listeners就可以了。</p></blockquote>]]></content>
      
      
    </entry>
    
    <entry>
      <title>大话设计模式笔记</title>
      <link href="/2018/06/26/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0-mabowen/"/>
      <url>/2018/06/26/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0-mabowen/</url>
      <content type="html"><![CDATA[<p>133</p><h4 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h4><p>1.命名要规范<br>2.代码逻辑要规范</p><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><ul><li>简单工厂模式</li><li>工厂模式</li><li>策略模式</li><li>装饰模式</li><li>代理模式</li><li>原型模式</li><li>外观模式</li><li>建造者模式</li><li>观察者模式</li></ul><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><p>面向对象有三大特性:封装,继承和多态  </p><p>面向对象有六大原则:</p><ul><li>单一责任原则</li><li>开放封闭原则</li><li>里氏替换原则 </li><li>接口隔离原则</li><li>依赖倒置原则</li><li>迪米特原则(最少知识原则)</li></ul><p>碰到问题就自觉得用计算机能理解得逻辑来描述和表达待解决的而问题及具体得求解过程,这样得思维缺使得外面得程序只为满足当前得需求,程序不容易维护,不容易拓展,不容易复用</p><p>面向对象的编程,并不是类越多越好,类的划分是为了封装,但分类的基础是抽象,具有相同的属性和功能的对象的抽象集合才是类</p><h4 id="面向对象得好处"><a href="#面向对象得好处" class="headerlink" title="面向对象得好处"></a>面向对象得好处</h4><p>通过封装,继承,多态把程序得耦合度降低,用设计模式使得程序更加得灵活,容易修改,易于复用.使得我们得代码更容维护,灵活性强,容易扩张和复用.</p><h4 id="业务的封装"><a href="#业务的封装" class="headerlink" title="业务的封装"></a>业务的封装</h4><p>编程有一原则,避免重复.<br>让业务与界面逻辑分开,让他们之间的耦合度下降,只有分离开,才可以达到维护或拓展.</p><h4 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h4><p>就一个类而言,应该仅有一个引起它变化的原因</p><p>遵循单一职责的优点:  </p><ul><li>降低了类的复杂度,一个类只负责一项职责  </li><li>提高了类的可读性,可维护性.</li><li>降低变更引起的风险</li></ul><h4 id="开放-封闭原则"><a href="#开放-封闭原则" class="headerlink" title="开放-封闭原则"></a>开放-封闭原则</h4><p>软件实体(类,模块,函数等等)应该是可以扩展,但是不可以修改.</p><p>开放-封闭原则是面向对象设计的核心所在.遵循这个原则可以带来面向对象技术所声称的巨大好处,也就是可维护,可扩展,可复用,灵活性好.开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象,然而,对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意,拒绝不成熟的抽象核抽象本身一样重要.</p><h4 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h4><p>高层模块不应该依赖于低层模块，二者都应该依赖其抽象；抽象不应该依赖于细节，细节应该依赖于抽象。因为相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构要比以细节为基础的架构要稳定的多。依赖倒置的中心思想是面向接口编程。上层模块不应该依赖于下层模块，应该依赖于接口。从而使得下层模块依赖于上层的接口，降低耦合度，提高系统的弹性。这六大原则是最虚，最抽象的，很难理解  </p><p>说白了就是针对接口编程,不要对实现编程</p><h4 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h4><p>一个软件实体如果使用的是一个父类的话,那么一定适用于其子类,而且它察觉不出父类对象和子类对象的区别.也就是说,在软件里面,把父类都替换成它的子类,程序的行为没有变化  </p><p>只有当子类可以替换掉父类,软件单位的功能不受影响时,父类才能真正被复用,而子类也能够在父类的基础上增加的新的行为,正是由于子类型的可替换性才使得父类类型的模块在无需修改的情况下就可以拓展</p><h4 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h4><p>如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用.如果其中一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用</p><p>迪米特法则其根本思想,是强调了类之间的松耦合<br>类之间的耦合越弱,越有利于复用,一个处于弱耦合的类被修改,不会对有关系的类造成波及</p><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>简单工厂模式是面对对象多态性的一个应用,他的好处在于:</p><ul><li>代码具有一定拓展性</li><li>遵循了单一责任原则 </li><li>属于面向接口编程</li><li>简单工厂模式提供了一个对外的类Client和实际工作的类,外界只需要传递特定的参数就可以调用不同的实际功能类,而不需要直接面对实际类与函数,拓展性大大增加</li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>它定义了算法家族,分别封装起来,让它们之间可以互相替换,此模式让算法变化,不会影响到使用算法的客户,我们着重得到对象某方法的运行结果  </p><p>策略模式就是用来封装算法,在实践中,我们发现可以用它来封装几乎任何类型的规则,只要在分析过程中听见需要在不同时间应用不同的业务规则,就可以考虑使用策略模式处理</p><h4 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h4><p>动态地给一个对象添加一些额外的职责,就增加功能来说,装饰模式比生成子类更为灵活</p><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>为其他对象提供一种代理以控制对这个对象的访问</p><ul><li>远程代理,也就是为一个对象在不同的地址空间提供局部代表.这样可以隐藏一个对象存在于不同地址空间的事实.</li><li>虚拟代理,是根据需要创建开销很大的对象.通过它来存放实例化需要很长时间的真实对象</li><li>安全代理,用来控制真实对象访问时和权限</li><li>智能指引,是指当调用真实的对象时,代理处理另一些事</li></ul><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>定义一个用于创建对象的接口,让子类决定实例化哪一个类.工厂方法使一个类的实例化延迟到其子类</p><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>用原型实例指定创建对象的种类,并且通过拷贝这些原型创建新的对象  </p><p>原型模式其实就是一个对象再创建另一个可定制的对象,而且不需要知道任何创建的细节.</p><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>我们要完成在某一细节层次一致的一个过程或一系列步骤,但其个别步骤在更详细的层次上的实现可能不同时,我们通常考虑用模板方法模式处理</p><p>定义一个操作中的算法的骨架,而将一些步骤延迟到子类中,模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p><p>当不变的和可变的行为在方法的子类实现中混合在一起的时候,不变的行为就会在子类中重复出现.我们通过模板方法模式把这些行为搬移到单一的地方,这样就帮助子类摆脱重复的不变行为的纠缠</p><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>为子系统中的一组接口提供一个一致的界面,此模式定义了一个高层接口,这个接口使得这一子系统更加容易使用</p><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>将一个复杂对象的构建与它的表示分离,使得同样的构造过程可以创建不同的表示</p><p>建造者模式的好处就是使得建造代码与表示代码分离,由于建造者隐藏了该产品是如何组装的所以若需要改变一个产品的内部表示,只需要再定义一个具体的建造者就可以了</p><p>建造者模式实在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式适用 的模式</p><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>定义了一种一对多的依赖关系,让多个观察者对象同时监听某一个主题对象.这个主题对象在状态发生变化时,会通知所有观察者对象,使他们能够自动更新自己</p><p>观察者模式所做的工作其实就是在接触耦合,让耦合的双方都依赖于抽象,而不是依赖于具体.从而使得各自的变化都不会影响另一边的变化</p><p>参考资料:<br><a href="https://segmentfault.com/a/1190000005748456" target="_blank" rel="noopener">设计模式总汇总</a><br><a href="https://segmentfault.com/a/1190000015231632" target="_blank" rel="noopener">设计模式六大原则</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>docker swarm</title>
      <link href="/2018/06/26/docker%E9%9B%86%E7%BE%A4%E7%AC%94%E8%AE%B0-chenhuaiyuan/"/>
      <url>/2018/06/26/docker%E9%9B%86%E7%BE%A4%E7%AC%94%E8%AE%B0-chenhuaiyuan/</url>
      <content type="html"><![CDATA[<font style="float:right;">陈怀远</font>  <p><br><br>下面内容随便写的，想到什么就写什么，所以很凌乱，如果打算接触docker swarm 的可以看看，说不定对你有帮助，如有实在想不通的地方可以亲自问本人。  </p><p>当一个线上业务做到一定程度的时候，服务器过度负载的时候，就必须通过增加服务器来缓解另外服务器的压力，提高性能。 这个时候，问题来了，如何让多台服务器实现高可用呢？</p><p>答案就是集群，给所有服务器做集群。  </p><h3 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h3><p>在docker中我们可以用swarm。<br>首先我们准备至少两台服务器，拿其中的一台服务器作为leader，在这台服务器上运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br><span class="line">// or</span><br><span class="line">docker swarm init --advertise-addr 192.168.x.x</span><br></pre></td></tr></table></figure><p>它会生成对应的token，类似于这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token \</span><br><span class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.x.x:2377</span><br></pre></td></tr></table></figure><p>如果你忘了leader上的token值，可以通过下面命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join-token manager</span><br></pre></td></tr></table></figure><p>这里有个需要注意的地方，不要忘了开启服务器对应的端口，docker swarm默认端口是2377</p><h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><p>我们可以把刚刚生成的token放到另一台服务器里面，在另一台服务器执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker swarm join --token \</span><br><span class="line">    SWMTKN-1-3z5rzoey0u6onkvvm58f7vgkser5d7z8sfshlu7s4oz2gztlvj-c036gwrakjejql06klrfc585r \</span><br><span class="line">    192.168.x.x:2377</span><br></pre></td></tr></table></figure><p>这个时候可以说我们的集群已经创好了，我们可以通过在leader服务器上运行<figure class="highlight docker"><figcaption><span>node ls``` 来查看</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 创建服务 </span></span><br><span class="line"></span><br><span class="line">接下来我们可以创建我们想要的服务，例如</span><br></pre></td></tr></table></figure></p><p>docker service create –name test –replicas 2 nginx:alpine<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然我们也可以通过docker compose来创建服务，我们可以自己写一个docker-compose.yml文件，例如：</span><br></pre></td></tr></table></figure></p><p>version: ‘3.2’<br>services:<br>  php-fpm:<br>    image: php:fpm-alpine<br>    volumes:</p><pre><code>  - ./html:/data/www/htmlcontainer_name: php-fpm</code></pre><p>  nginx:<br>    image: nginx:alpine<br>    volumes:</p><pre><code>  - ./nginx.cnf:/etc/nginx/conf.d  - ./html:/data/www/htmlports:  - &quot;80:80&quot;container_name: nginx</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里需要注意的是docker compose只有版本3才支持swarm,还有就是volumes所对应的目录必须在另一台服务器上也有，要不然会出现两个应用容器都装在leader服务器上，再需要注意的是两台服务器上必须都要有相对应的容器镜像，要不然会创建失败，我们可以通过</span><br><span class="line">```docker compose pull``` 来拉取</span><br><span class="line"></span><br><span class="line">这些工作做完之后我们就可以部署了，命令如下</span><br></pre></td></tr></table></figure><p>docker stack deploy -c docker-compose.yml test<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它会自动把两个容器部署到两台服务器上，让人感觉就像是在一台服务器上一样。  </span><br><span class="line">注意：在创建集群的时候最好是内网服务器集群，不要用不同网络的，不同网络会出现另一台服务器部署失败  </span><br><span class="line"></span><br><span class="line">我们可以通过scale来修改容器数量</span><br></pre></td></tr></table></figure></p><p>docker service scale service_name=2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它会自动部署到服务器上</span><br><span class="line"></span><br><span class="line">它默认会自动创建一个网络，如果想要自己定义，可以在docker compose里面定义</span><br><span class="line"></span><br><span class="line">### 删除服务</span><br><span class="line"></span><br><span class="line">如果我们想要删除服务可以运行以下命令</span><br></pre></td></tr></table></figure></p><p>docker service rm service_name<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 脱离集群</span><br><span class="line"></span><br><span class="line">如果我们想要脱离集群，我们可以运行以下命令：</span><br></pre></td></tr></table></figure></p><p>docker swarm leave<br>// or<br>docker swarm leave –force<br><code>`</code></p><p>这里说一点，最新版的 Swarm 提供自动服务发现与集群负载功能。</p><p>关于docker swarm，我就先写那么多。如有时间，再完善。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>HTTP状态码</title>
      <link href="/2018/06/26/http%E5%93%8D%E5%BA%94%E7%A0%81-mabowen/"/>
      <url>/2018/06/26/http%E5%93%8D%E5%BA%94%E7%A0%81-mabowen/</url>
      <content type="html"><![CDATA[<ul><li><p>200s:请求被接受,并且服务器没有发生错误</p></li><li><p>300s:重定向 </p></li><li><p>400s:客户端错误<br>一般来说是指请求出现问题,这可能是浏览器原因,或者是使用得url有问题</p></li><li><p>401s:未授权</p></li><li><p>403s:禁止访问</p></li><li><p>404s:不确定这个资源是否存在</p></li><li><p>407s:需要代理服务器授权</p></li><li><p>408s:超时</p></li><li><p>409s:冲突  </p></li><li><p>410s:这是一种资源曾经存在的情况，但已被永久删除，并且不会返回。 如果您从网站上永久删除了一个页面，则应该使用 410，而不是 404。</p></li><li><p>500s:服务器错误</p></li><li><p>502s:网关错误</p></li><li><p>503s:服务暂时不可用</p></li><li><p>504s:网关超时</p></li></ul><p>详情:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank" rel="noopener">HTTP响应码</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Markdown 语法手册</title>
      <link href="/2018/06/13/markdown%E6%89%8B%E5%86%8C-mabowen/"/>
      <url>/2018/06/13/markdown%E6%89%8B%E5%86%8C-mabowen/</url>
      <content type="html"><![CDATA[<p>Markdown 可以嵌套html</p><h3 id="斜体与粗体"><a href="#斜体与粗体" class="headerlink" title="斜体与粗体"></a>斜体与粗体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.*斜体*或者_斜体_</span><br><span class="line">2.**粗体**</span><br><span class="line">3.***加粗斜体***</span><br><span class="line">4.~~删除线~~</span><br></pre></td></tr></table></figure><h4 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果:"></a>显示效果:</h4><ul><li><em>这是一段斜体</em></li><li><strong>这是一段粗体</strong></li><li><strong><em>这是一段加粗斜体</em></strong></li><li><del>这是一段删除线</del></li></ul><h3 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h3><h4 id="第一种写法"><a href="#第一种写法" class="headerlink" title="第一种写法:"></a>第一种写法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.这是一个一级标题</span><br><span class="line">2.================</span><br><span class="line">3.</span><br><span class="line">4.这是一个二级标题</span><br><span class="line">5.----------------</span><br></pre></td></tr></table></figure><h4 id="第二种写法"><a href="#第二种写法" class="headerlink" title="第二种写法:"></a>第二种写法:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.# 一级标题</span><br><span class="line">2.## 二级标题</span><br><span class="line">3.### 三级标题</span><br><span class="line">4.#### 四级标题</span><br></pre></td></tr></table></figure><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><h4 id="Markdown-支持两种形式的超链接语法-行内式与参考式"><a href="#Markdown-支持两种形式的超链接语法-行内式与参考式" class="headerlink" title="Markdown 支持两种形式的超链接语法:行内式与参考式"></a>Markdown 支持两种形式的超链接语法:行内式与参考式</h4><h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明:"></a>语法说明:</h4><ul><li><h5> []里写链接文字，()里写链接地址, ()中的”“中可以为链接指定title属性，title属性可加可不加。title属性的效果是鼠标悬停在链接上会出现指定的 title文字。<a href="链接地址 “链接标题”">链接文字</a>这样的形式。链接地址与链接标题前有一个空格。</h5></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.[百度](&apos;https://www.baidu.com/&apos;)</span><br><span class="line">2.[百度](&apos;https://www.baidu.com/&apos;&quot;百度&quot;)</span><br></pre></td></tr></table></figure><p>显示效果<br> <a href="&#39;https://www.baidu.com/&#39;">百度</a><br> <a href="&#39;https://www.baidu.com/&#39;&quot;百度&quot;">百度</a></p><h4 id="参考式"><a href="#参考式" class="headerlink" title="参考式"></a>参考式</h4><p>参考式超链接一般用在学术论文上面，或者另一种情况，如果某一个链接在文章中多处使用，那么使用引用 的方式创建链接将非常好，它可以让你对链接进行统一的管理。</p><p>语法说明：<br>参考式链接分为两部分，文中的写法 [链接文字][链接标记]，在文本的任意位置添加[链接标记]:链接地址 “链接标题”，链接地址与链接标题前有一个空格。</p><p>如果链接文字本身可以做为链接标记，你也可以写成[链接文字][]<br>[链接文字]：链接地址的形式，见代码的最后一行。<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.我经常去的几个网站[Google][1]、[Leanote][2]以及[自己的博客][3]</span><br><span class="line">2.[Leanote 笔记][2]是一个不错的[网站][]。</span><br><span class="line">3. [1]:http://www.google.com &quot;Google&quot;</span><br><span class="line">4. [2]:http://www.leanote.com &quot;Leanote&quot;</span><br><span class="line">5. [3]:http://http://blog.leanote.com/freewalk &quot;梵居闹市&quot;</span><br><span class="line">6. [网站]:http://http://blog.leanote.com/freewalk</span><br></pre></td></tr></table></figure><p>显示效果:<br>我经常去的几个网站<a href="http://www.google.com" title="Google" target="_blank" rel="noopener">Google</a>、<a href="http://www.leanote.com" title="Leanote" target="_blank" rel="noopener">Leanote</a>以及<a href="http://http://blog.leanote.com/freewalk" title="梵居闹市" target="_blank" rel="noopener">自己的博客</a><br><a href="http://www.leanote.com" title="Leanote" target="_blank" rel="noopener">Leanote 笔记</a>是一个不错的<a href="http://http://blog.leanote.com/freewalk" target="_blank" rel="noopener">网站</a>。</p><h4 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h4><h5 id="语法说明-1"><a href="#语法说明-1" class="headerlink" title="语法说明:"></a>语法说明:</h5><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接[目录]。一般网址的链接文字就和链接地址一样，例如：<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.&lt;www.baidu.com&gt;</span><br><span class="line">2.&lt;610286632@qq.com&gt;</span><br></pre></td></tr></table></figure><p>显示效果<br><a href="http://baidu.com/" target="_blank" rel="noopener">http://baidu.com/</a><br><a href="mailto:&#54;&#x31;&#x30;&#50;&#56;&#x36;&#x36;&#51;&#x32;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#54;&#x31;&#x30;&#50;&#56;&#x36;&#x36;&#51;&#x32;&#64;&#113;&#113;&#x2e;&#99;&#111;&#x6d;</a></p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>使用*,+,-表示无序列表.<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. - 无序列表</span><br><span class="line">2. + 无序列表</span><br><span class="line">3. * 无序列表</span><br></pre></td></tr></table></figure><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>有序列表则使用数字接着一个英文句点。<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表项 </span><br><span class="line">2. 有序列表项 </span><br><span class="line">3. 有序列表项</span><br></pre></td></tr></table></figure><p>显示效果:  </p><ol><li>有序列表项  </li><li>有序列表项   </li><li>有序列表项 </li></ol><h4 id="定义型列表"><a href="#定义型列表" class="headerlink" title="定义型列表"></a>定义型列表</h4><p>语法说明:<br>定义型列表由名词和解释组成。一行写上定义，紧跟一行写上解释。解释的写法:紧跟一个缩进(Tab)<br>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Markdown</span><br><span class="line">:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line">代码块 2</span><br><span class="line">:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</span><br><span class="line">        代码块（左侧有八个不可见的空格）</span><br></pre></td></tr></table></figure><p>显示效果<br>Markdown<br>:    轻量级文本标记语言，可以转换成html，pdf等格式（左侧有一个可见的冒号和四个不可见的空格）</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>语法说明:<br>引用需要在被引用的文本前加上&gt;符号<br>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">*   阅读的方法:</span><br><span class="line"></span><br><span class="line">&gt; 1.   这是第一行列表项。</span><br><span class="line">&gt; 2.   这是第二行列表项。</span><br><span class="line">&gt; </span><br><span class="line">&gt; 给出一些例子代码：</span><br><span class="line">&gt; </span><br><span class="line">&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</span><br><span class="line"></span><br><span class="line">允许偷懒只在整个段落前第一行加上&gt;:</span><br><span class="line">&gt; 打开书本</span><br><span class="line">打开电灯</span><br></pre></td></tr></table></figure><p>显示效果:</p><blockquote><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;); </code></pre></blockquote><p>允许偷懒只在整个段落前第一行加上&gt;:</p><blockquote><p>打开书本<br>打开电灯</p></blockquote><h3 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h3><p>图片的创建方式与超链接相似，而且和超链接一样也有两种写法，行内式和参考式写法。</p><p>语法中图片Alt的意思是如果图片因为某些原因不能显示，就用定义的图片Alt文字来代替图片。 图片Title则和链接中的Title一样，表示鼠标悬停与图片上时出现的文字。 Alt 和 Title 都不是必须的，可以省略，但建议写上</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">行内式:</span><br><span class="line">美丽花儿： </span><br><span class="line">![美丽花儿](http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg &quot;美丽花儿&quot;)</span><br><span class="line"></span><br><span class="line">参考式  </span><br><span class="line">美丽花儿：</span><br><span class="line">![美丽花儿][flower]</span><br><span class="line">[flower]:http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg  &quot;美丽花儿&quot;</span><br></pre></td></tr></table></figure><p>显示效果:<br>行内式<br>美丽花儿：<br><img src="http://ww2.sinaimg.cn/large/56d258bdjw1eugeubg8ujj21kw16odn6.jpg" alt="美丽花儿" title="美丽花儿"></p><h3 id="注脚"><a href="#注脚" class="headerlink" title="注脚"></a>注脚</h3><p>语法说明：<br>在需要添加注脚的文字后加上脚注名字称为加注。 然后在文本的任意位置(一般在最后)添加脚注，脚注前必须有对应的脚注名字。<br>注意：经测试注脚与注脚之间必须空一行，不然会失效。成功后会发现，即使你没有把注脚写在文末，经Markdown转换后，也会自动归类到文章的最后。</p><p>代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote[^Le] 编辑器进行书写。</span><br><span class="line"></span><br><span class="line">[^1]:Markdown是一种纯文本标记语言</span><br><span class="line"></span><br><span class="line">[^2]:HyperText Markup Language 超文本标记语言</span><br><span class="line"></span><br><span class="line">[^Le]:开源笔记平台，支持Markdown和笔记直接发为博文</span><br></pre></td></tr></table></figure><p>显示效果:<br>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2], 你可以使用 Leanote<a href="开源笔记平台，支持Markdown和笔记直接发为博文">^Le</a> 编辑器进行书写。</p><p>[^2]:HyperText Markup Language 超文本标记语言</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * *</span><br><span class="line">***</span><br><span class="line">*****</span><br><span class="line">- - -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><p>显示效果都一样：</p><hr><hr>]]></content>
      
      
    </entry>
    
    <entry>
      <title>git学习</title>
      <link href="/2018/06/13/git%E5%AD%A6%E4%B9%A0-mabowen/"/>
      <url>/2018/06/13/git%E5%AD%A6%E4%B9%A0-mabowen/</url>
      <content type="html"><![CDATA[<p>参照 廖雪峰git教程 原文-<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">git教程</a></p><h3 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h3><p>什么是版本库,可以理解为成一个目录,目录的所有文件都可以被git管理起来,每个文件的修改,删除,git都能跟踪,以便任何时刻可以追踪到历史,或者在将来某个时刻可以还原.<br>创建版本库非常简单,首先,选择一个合适的地方,创建一个空目录:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir mabowen (创建文件夹)</span><br><span class="line">$ cd mabowen </span><br><span class="line">$ pwd 显示路径</span><br></pre></td></tr></table></figure><p>注意:windows系统目录名不包含中文<br>通过git init命令可以把这个目录变成git可以管理的仓库:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in E:/mabowen/.git/</span><br></pre></td></tr></table></figure><p>编写一个readme.txt文件 一定要放在自己所创建的目录下 git才能找到<br>第一步,用git add把文件添加到仓库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></table></figure><p>没有消息提示是正确的</p><p>第二步,用git commit告诉git,把文件提交到仓库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m&apos;test&apos;</span><br><span class="line">[master (root-commit) 12ee85d] test</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure></p><p>-m后面输入的是本次提交的内容,最好是有意义的,下次可以从历史记录中找到改动记录  </p><ul><li>1 file changed 一个文件被改动  </li><li>2 insertions 插入了两条内容  </li></ul><p>git add 可以 添加很多文件<br>git commit -m 可以一次性全部提交</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add test1.txt test2.txt</span><br><span class="line">$ git commit -m&apos;test&apos;</span><br></pre></td></tr></table></figure><h3 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h3><p>git status 命令可以告诉我们当前的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure><p>上面的命令告诉我们 readme.txt 被修改过但是还没准备提交的修改  </p><p>git diff可以查看不同 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 46d49bf..9247db6 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a version control system.</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure><p>可以看到我们在第一行添加了 distributed 单词<br>接着在执行 git add 在 git commit 之前再运行 git status 查看当前仓库的状态<br>提交后,在用git status 查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>git 告诉我们当前没有需要修改的地方,而且工作目录是干净的</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>git log 命令可以查看历史记录, 我们可以看见最近的提交 如果嫌输出信息太多,可以加 –pretty=oneline  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">a922e70b941dbdb2bacaa9cf4ba35ad8bdeee8c3 (HEAD -&gt; master) test</span><br><span class="line">12ee85d9bfdaeed13bd6dfa85f911b0cbad0849a test</span><br></pre></td></tr></table></figure><blockquote><p>a992这一串是commit id 是(版本号)首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交a992(注意我的提交ID和你的肯定不一样)，上一个版本就是HEAD^  ，上上一个版本就是HEAD^^ ,当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100</p></blockquote><p>如果要回退到上一个版本 就可以用 git reset</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 12ee85d test</span><br></pre></td></tr></table></figure><p>如果想回去 找到commit id 就可以回去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard a922</span><br><span class="line">HEAD is now at a922e70 test</span><br></pre></td></tr></table></figure><p>版本号可以不用写全,git可以自己去找,当然也不能只写一两位,因为,git可以找到多个版本就无法确定是哪一个.<br>git的版本回退速度非常快,因为git在内部有个指向当前版本的HEAD指针,当你回退版本的时候,git就只是把HEAD指针指向那个版本</p><p>小结  </p><ul><li><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset –hard commit_id。</p></li><li><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p></li><li><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p></li></ul><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>工作区<br>就是你电脑能看见的目录是一个工作区<br>版本库<br>工作区有一个隐藏的.git,这个不算工作区,而是git的版本库.<br>git add 把文件添加到暂存区<br>git commit 提交更改 相当于把暂存区的所有内容提交当前分支<br>一旦提交后,如果你又没有对工作区做任何修改,那么工作区就是干净的  </p><p>管理修改<br>第一次修改-&gt;git add-&gt;第二次修改-&gt;git commit<br>当你第一次git add 命令提交了 在工作区第一次修改放入暂存区,准备提交,但是工作区的第二次修改并没有放入暂存区,所以git commit 只是把暂存区的修改提交了,也就是第一次修改提交了,第二次修改没有提交</p><p>那么如何提交二次修改呢<br>第一次修改-&gt;git add-&gt;第二次修改-&gt;git add-&gt;git commit<br>如果每次修改不用git add 放到暂存区就不会加入commit中</p><p>撤销修改<br>git chekout –file 可以丢弃工作区的修改  把file在工作区的修改全部撤销,这里有两种情况  </p><ul><li>一种文件修改后还没有被放到暂存区,现在,撤销修改就回到和版本库一摸一样的状态;  </li><li>一种文件已经添加到暂存区后,又做了修改,现在,撤销修改就回到添加到暂存区后的状态.<br>总之就是让这个文件回到最近一次 git commit 或 git add 时的状态</li></ul><p>git reset HEADfile 可以把暂存区的修改撤销掉,重新放回工作区:  </p><p>小结</p><ul><li>场景一:当你改乱工作区某一个文件的内容,想直接丢弃工作区的修改时候,用git chekout – file</li><li>场景二:当你不但该乱了工作区某个文件的内容,还添加到暂存区,想丢弃修改,分两步 第一步 用git reset HEAD file 回到场景一 第二步按场景一操作  </li><li>已经提交了不合适的修改到版本库想撤销本次提交,可以用版本回退一节,前提是没有推送到远端库  </li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>一般情况下你通常直接把没用的文件删了,这时候git知道你删除了文件,工作区和版本库就不一致了,git status 命令告诉你哪些文件被删除了<br>这时候,你有两个选择  </p><ul><li>从版本库中删除该文件,哪就用命令git rm 删除,并且git commit</li><li>另一种是删错了,因为版本库还有,可以轻松的把文件恢复到最新版本</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- test.txt</span><br></pre></td></tr></table></figure><p>git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h3 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h3><p>在看分支管理前,首先明确工作区和暂存区的概念,以及各种命令的用法,以及commit是加到暂存区这类的概念问题</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>在每次提交,git都把他们串成一条时间线,这条时间线就是一个分支,只有一条时间线,在git里这个分支叫主分支,即master分支.HEAD严格来说不是指向提交,而是指向master,master才是指向提交的,所以,HEAD指向确定当前分支.<br>也就是说是master 指向版本 HEAD去指向你是处于什么分支<br>每次提交master分支都会向前一步,这样随你不断的提交,master分支的线越来越长.<br>当我们创建新的分支,比如我们创建一个mabowen的分支基于master,再把HEAD指向mabowen就表示当前分支在mabowen上 现在开始对工作区的提交和修改都是在mabowen分支上开发,每一次新的提交,mabowen指针往前一步,而master指针不变</p><p>小结  </p><ul><li>查看分支：git branch</li><li>创建分支：git branch <name>  </name></li><li>切换分支：git checkout <name></name></li><li>创建+切换分支：git checkout -b <name></name></li><li>合并某分支到当前分支：git merge <name></name></li><li>删除分支：git branch -d <name></name></li></ul><h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>当git无法自动合并分支时,就必须首先解决冲突.解决冲突以后,在提交,合并完成.<br>解决冲突就是把git合并失败的文件手动编辑为我们希望的内容,在提交.<br>用git log –graph可以查看分支合并图    </p><blockquote><p>以上是个人理解 有些不足 可以看廖雪峰git的教程 更加完善 </p></blockquote><h3 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h3><p>git提供了一个git stash功能 可以把当前的工作现场储藏起来等以后恢复现场后继续工作</p><blockquote><p>详细见原教程</p></blockquote><h3 id="多人开发"><a href="#多人开发" class="headerlink" title="多人开发"></a>多人开发</h3><p>当你从远端克隆时,实际上git自动把本地的master分支和远程的matser 分支对应起来了,并且,远程仓库的默认名称是origin.    </p><p>要查看远端库的信息,用git remote 命令</p><p>或者,用git remote -v 显示跟详细的信息 </p><p>上面显示可以抓取和推送的origin的地址,如果没有推送权限就看不到push地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (fetch)</span><br><span class="line">origin  git@github.com:michaelliao/learngit.git (push)</span><br></pre></td></tr></table></figure><p>推送分支 </p><p>推送分支,就是把该分支上所有本地提交推送到远程库.推送时,要指定本地分支,这样,git就会把分支推送到远程库对应的远程分支上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>如果要推送其他分支,比如dev,就改成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$git push origin dev</span><br></pre></td></tr></table></figure><p>抓取分支<br>多人协作时,大家都会往master和dev分支上推送各自的修改.<br>现在,模拟一个你的小伙伴,可以在另一个电脑,或者同一个电脑的另一个目录下克隆:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao/learngit.git</span><br><span class="line">Cloning into &apos;learngit&apos;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21/21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40/40), done.</span><br><span class="line">Resolving deltas: 100% (14/14), done.</span><br></pre></td></tr></table></figure><p>当你从远程库clone时，默认情况下，你只能看到本地的master分支。不信可以用git branch命令看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><p>现在你要在dev分支上开发,就必须创建远端origin的dev分支到本地,于是你可以用这个命令创建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>然后他就可以在dev上继续修改,然后,可以push到远程  </p><p>当我们本地的master分支落后于远端的master分支时候一个提交时候 这时你上传到远端就上传不上去,需要先从远端pull下代码 这时就可能会引起冲突,原因可能是因为你本地的代码与远端的pull下的代码有共同修改的地方 </p><p>这时候需要解决冲突</p><p>因此，多人协作的工作模式通常是这样：</p><p>首先，可以试图用git push origin <branch-name>推送自己的修改；</branch-name></p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！</branch-name></p><p>如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch –set-upstream-to <branch-name> origin/<branch-name>。</branch-name></branch-name></p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><ul><li><p>reabse操作可以把本地未push的分支提交历史整理成直线;</p></li><li><p>rebase的目的是使得我们在查看历史提交的变化更容易,因为分叉提交需要三方那对比</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>git经验之谈</title>
      <link href="/2018/06/13/git%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88-chenhuaiyuan/"/>
      <url>/2018/06/13/git%E7%BB%8F%E9%AA%8C%E4%B9%8B%E8%B0%88-chenhuaiyuan/</url>
      <content type="html"><![CDATA[<font style="float:right;">陈怀远</font>  <p><font size="0px"><br>git是一个代码管理工具，一般用于团队开发协作。git的使用方法我就不说了，主要说说git的使用技巧。</font></p><h2 id="如何轻易记住命令"><a href="#如何轻易记住命令" class="headerlink" title="如何轻易记住命令"></a>如何轻易记住命令</h2><p>  在你使用git的时候，一般你很难记住git命令，尤其是刚学习的时候。那怎么样才能让我们更好的记住git命令呢，这里我推荐两个方法。  </p><h5 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h5><p>  当你安装了git之后，在你的用户目录下面会有一个.gitconfig文件，你可以在这个文件里面加入alias标签，顾名思义，就是给git取个别名，取一个你熟悉的名字，这样你就能记住这个命令了，下面我将给出我的别名配置。  </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[alias]</span><br><span class="line">        s = status --short --branch</span><br><span class="line">        ss = status</span><br><span class="line">        brd = branch -D</span><br><span class="line">        brm = branch -m</span><br><span class="line">        br = branch</span><br><span class="line">        bra = branch --all</span><br><span class="line">        ci = commit</span><br><span class="line">        cim = commit -m</span><br><span class="line">        cia = commit -a</span><br><span class="line">        co = checkout</span><br><span class="line">        cob = checkout -b</span><br><span class="line">        fe = fetch origin</span><br><span class="line">        fp = fetch origin -p</span><br><span class="line">        last = log -1 HEAD</span><br><span class="line">        unstage = reset HEAD --</span><br><span class="line">        lg = &quot;log --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commit --date=relative&quot;</span><br><span class="line">        mg = merge --squash --no-commit</span><br><span class="line">        pl = pull</span><br><span class="line">        plo = pull origin</span><br><span class="line">        ph = push</span><br><span class="line">        pho = push origin</span><br><span class="line">        df = diff</span><br><span class="line">        stl = stash list</span><br><span class="line">        st = stash</span><br><span class="line">        stp = stash pop</span><br><span class="line">        sta = stash apply</span><br><span class="line">        sts = stash save</span><br><span class="line">        stc = stash clear</span><br><span class="line">        rb = rebase</span><br><span class="line">        rba = rebase --abort</span><br><span class="line">        rec = rebase --continue</span><br></pre></td></tr></table></figure><h5 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h5><p>  修改你的shell配置文件，你可以在命令行输入<figure class="highlight plain"><figcaption><span>$SHELL```查看你当前使用的shell，我用的是zsh，如果你使用的是bash，最好用版本4.0以上的，因为好像只用4.0及以上才能使用alias。你可以在用户目录下面找到相应的配置文件，我的是.zshrc, 如果是bash，配置文件应该是.bashrc。打开配置文件。你可以在配置文件最后加上以下代码。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></p><p>  alias pull=”git pull”<br>  alias push=”git push”<br>  alias st=”git status”<br>  alias g=”git”<br>  <code>`</code></p><p>  你可以按照你自己的习惯来取自己喜欢的别名，当你添加完别名后只需要重启终端就可以使用了。</p><h2 id="开发上的建议"><a href="#开发上的建议" class="headerlink" title="开发上的建议"></a>开发上的建议</h2><p>  永远不要在master分支上开发，为了不污染分支，我个人的建议是创建一个个人分支，在个人分支上进行开发，当要提交代码的时候就把自己的分支和要提交的分支合并。这样做的好处，你可以清晰的知道自己在干什么，可以让你避免不必要的麻烦。<br>  在提交代码的时候，一定要先pull一下代码，这是必须的，因为我们无法知道线上的分支和自己的分支指针是不是一样的。当然，如果你没pull然后提交出现了无法提交问题也是可以解决的，这个时候我们可以使用rebase来同步分支的指针。当然，当你提交完后最好把本地的当前分支删除，重新从线上拉取。</p><p>  编写未完，后期补充。</p>]]></content>
      
      
    </entry>
    
  
  
</search>
